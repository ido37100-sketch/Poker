<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Poker Tournament Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    
    <!-- Firebase Configuration -->
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCT09_GK0utPaJfIFdHD6F0qPfv19kCxuA",
            authDomain: "poker-tournament-manager-f7b51.firebaseapp.com",
            databaseURL: "https://poker-tournament-manager-f7b51-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "poker-tournament-manager-f7b51",
            storageBucket: "poker-tournament-manager-f7b51.firebasestorage.app",
            messagingSenderId: "236754036600",
            appId: "1:236754036600:web:96c38b1e3ba87fff8c0a8d",
            measurementId: "G-EFKBQ70BXY"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        
                 // Generate unique room ID for this session
         const roomId = generateRoomId();
         
         // Generate unique device ID
         const deviceId = generateDeviceId();
         
         function generateRoomId() {
           // Generate a 6-character room ID
           const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
           let result = '';
           for (let i = 0; i < 6; i++) {
             result += chars.charAt(Math.floor(Math.random() * chars.length));
           }
           return result;
         }
         
         function generateDeviceId() {
           // Generate a unique device ID
           const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
           let result = '';
           for (let i = 0; i < 8; i++) {
             result += chars.charAt(Math.floor(Math.random() * chars.length));
           }
           return result;
         }
    </script>
    
    <style>
      :root { color-scheme: dark; }
      body { background-color: rgb(15 23 42); color: rgb(226 232 240); }
       
       /* Fix for Spotify iframe white background */
       iframe {
         background: transparent !important;
         border: none !important;
         outline: none !important;
       }
       
               /* Ensure no white backgrounds in the widget */
        .spotify-widget iframe,
        .spotify-widget * {
          background: transparent !important;
        }
        
        /* Force iframe to fill container completely */
        .spotify-widget iframe {
          min-height: 100% !important;
          height: 100% !important;
          background: transparent !important;
        }
        
        /* Remove any default margins/padding that might cause gaps */
        .spotify-widget {
          overflow: hidden;
        }
    </style>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="min-h-screen">
    <div id="root"></div>
    


    <script type="text/babel" data-presets="react">
      const { useEffect, useMemo, useRef, useState } = React

             function App() {
         // Core tournament state
         const [isRunning, setIsRunning] = useState(false)
         const [gameStarted, setGameStarted] = useState(false) // New: tracks if game has officially started
         const [currentLevelIndex, setCurrentLevelIndex] = useState(0)
         const [remainingSeconds, setRemainingSeconds] = useState(600) // 10 minutes default
         const [minutesPerLevel, setMinutesPerLevel] = useState(10)
         const [timeFormat, setTimeFormat] = useState('minutes') // 'minutes' or 'mmss'
         const [timePerLevelMMSS, setTimePerLevelMMSS] = useState('10:00') // MM:SS format
         const [soundEnabled, setSoundEnabled] = useState(true)
         
         // Tournament timing
         const [elapsedSeconds, setElapsedSeconds] = useState(0)
         const [breakSeconds, setBreakSeconds] = useState(0)
         const [isOnBreak, setIsOnBreak] = useState(false)
         const [autoBreakMinutes, setAutoBreakMinutes] = useState(0)
          const [addonSeconds, setAddonSeconds] = useState(0)
         
         // Player management
         const [numPlayers, setNumPlayers] = useState(6)
         
         // Wrapper function to prevent player count changes after game starts
         const updateNumPlayers = (newCount) => {
           if (gameStarted) {
             console.log('ğŸš« Cannot change player count after game has started')
             return
           }
           
           // Validate the new count
           if (newCount < 2 || newCount > 20) {
             console.log('ğŸš« Invalid player count:', newCount, 'Must be between 2 and 20')
             return
           }
           
           console.log('ğŸ”„ Updating player count from', numPlayers, 'to', newCount)
           
           // Set flag to prevent useEffect from interfering
           setIsUpdatingPlayers(true)
           
           // Calculate the new players array immediately
           let newPlayers, newRebuyCounts, newEliminatedIds
           
           if (newCount > players.length) {
             // Add new players
             newPlayers = [...players]
             for (let i = players.length; i < newCount; i++) {
               newPlayers.push({ 
                 id: i + 1, 
                 name: t.playerPlaceholder(i + 1)
               })
             }
           } else if (newCount < players.length) {
             // Remove excess players
             newPlayers = players.slice(0, newCount)
             
             // Also remove rebuys and eliminated status for removed players
             newRebuyCounts = { ...rebuyCounts }
             newEliminatedIds = [...eliminatedIds]
             
             for (let i = newCount; i < players.length; i++) {
               delete newRebuyCounts[i + 1]
               newEliminatedIds = newEliminatedIds.filter(id => id !== i + 1)
             }
           } else {
             // Same count, no changes needed
             newPlayers = players
           }
           
           // Update all state at once
           setNumPlayers(newCount)
           setPlayers(newPlayers)
           if (newRebuyCounts) setRebuyCounts(newRebuyCounts)
           if (newEliminatedIds) setEliminatedIds(newEliminatedIds)
           
           // Sync to Firebase immediately with the new state
           setTimeout(() => {
             try {
               syncGameState({
                 isRunning,
                 gameStarted,
                 players: newPlayers,
                 eliminatedIds: newEliminatedIds || eliminatedIds,
                 rebuyCounts: newRebuyCounts || rebuyCounts,
                 currentLevelIndex,
                 remainingSeconds,
                 breakSeconds,
                 isOnBreak,
                 addonBreakTriggered,
                 addonBreakPending,
                 spotifyUrl,
                 currentTrack
               })
             } catch (error) {
               console.error('Error syncing to Firebase:', error)
             }
           }, 50) // Reduced delay for faster sync
         }
         const [players, setPlayers] = useState(() => 
           Array.from({ length: 6 }, (_, i) => ({ 
             id: i + 1, 
             name: `×©×—×§×Ÿ ${i + 1}` 
           }))
         )
         const [eliminatedIds, setEliminatedIds] = useState([])
         const [rebuyCounts, setRebuyCounts] = useState({})
         
         // Blind levels
         const [levels, setLevels] = useState([
           { level: 1, smallBlind: 25, bigBlind: 50 },
           { level: 2, smallBlind: 50, bigBlind: 100 },
           { level: 3, smallBlind: 100, bigBlind: 200 },
           { level: 4, smallBlind: 200, bigBlind: 400 },
           { level: 5, smallBlind: 400, bigBlind: 800 },
           { level: 6, smallBlind: 800, bigBlind: 1600 },
           { level: 7, smallBlind: 1600, bigBlind: 3200 },
           { level: 8, smallBlind: 3200, bigBlind: 6400 },
           { level: 9, smallBlind: 6400, bigBlind: 12800 },
           { level: 10, smallBlind: 12800, bigBlind: 25600 },
           { level: 11, smallBlind: 25600, bigBlind: 51200 },
           { level: 12, smallBlind: 51200, bigBlind: 102400 }
         ])
         
         // User default blind levels
         const [userDefaultLevels, setUserDefaultLevels] = useState(null)
         
                            // App access control
         const [isAppUnlocked, setIsAppUnlocked] = useState(false)
         const [showAppLogin, setShowAppLogin] = useState(true)
         const [appPassword, setAppPassword] = useState('')
         const [selectedAction, setSelectedAction] = useState(null) // 'new' or 'load'
         const [isRestoring, setIsRestoring] = useState(false) // Flag to prevent interference during restore
         
         // Admin mode
         const [isAdminMode, setIsAdminMode] = useState(false)
         const [showAdminLogin, setShowAdminLogin] = useState(false)
         const [adminPassword, setAdminPassword] = useState('')
                    const [requestedAdminMode, setRequestedAdminMode] = useState(null)
           
           // Addon break system
           const [addonBreakTriggered, setAddonBreakTriggered] = useState(false)
           const [addonBreakPending, setAddonBreakPending] = useState(false)
           
           // Tournament settings
          const [maxRebuys, setMaxRebuys] = useState(3)
          const [addonTime, setAddonTime] = useState('')
          const [numWinners, setNumWinners] = useState(3)
         
         // Prize calculator
         const [prizePool, setPrizePool] = useState(1000)
         const [ratioInput, setRatioInput] = useState('50/30/20')
         
         // Tournament pricing
         const [buyInPrice, setBuyInPrice] = useState(50)
         const [rebuyPrice, setRebuyPrice] = useState(50)
         const [currency, setCurrency] = useState('USD')
           const [lowestChipValue, setLowestChipValue] = useState(25)
         const [desiredNumberOfLevels, setDesiredNumberOfLevels] = useState(12)
         
         // Spotify
         const [spotifyUrl, setSpotifyUrl] = useState('')
         const [currentTrack, setCurrentTrack] = useState(null)
         
         // Language
         const [lang, setLang] = useState('he')
         
         // Firebase real-time sync
         const [isConnected, setIsConnected] = useState(false)
         const [lastUpdateTime, setLastUpdateTime] = useState(null)
         const [joinRoomCode, setJoinRoomCode] = useState('')
         const [isUpdatingPlayers, setIsUpdatingPlayers] = useState(false)
         const [isHost, setIsHost] = useState(false)
         const [hostId, setHostId] = useState(null)
         const [isJoiningRoom, setIsJoiningRoom] = useState(false)
         const [hostLocked, setHostLocked] = useState(false) // Prevent host changes once locked
         
         // Protected host setter that respects the lock
         const setProtectedHost = (newHostStatus) => {
           if (!hostLocked) {
             setIsHost(newHostStatus)
           } else {
             console.log('ğŸš« Host status locked - cannot change from', isHost, 'to', newHostStatus)
           }
         }
         
         // Global host protection - ensure guests can never become host
         const enforceHostProtection = () => {
           if (hostLocked && isHost) {
             console.log('ğŸš¨ GLOBAL HOST PROTECTION: Forcing guest status')
             setIsHost(false)
           }
         }
         
         // Host status change protection
         useEffect(() => {
           if (hostLocked && isHost) {
             console.log('ğŸš¨ HOST STATUS CHANGE PROTECTION: Detected unauthorized host change')
             setIsHost(false)
           }
         }, [isHost, hostLocked])
         
         // Force host status check on room join
         const forceHostStatusCheck = () => {
           const currentRoomId = getCurrentRoomId()
           if (currentRoomId && isJoiningRoom) {
             // Force check the current host status
             const hostRef = database.ref(`rooms/${currentRoomId}/gameState/hostId`)
             hostRef.once('value', (snapshot) => {
               if (snapshot.exists()) {
                 const existingHostId = snapshot.val()
                 if (existingHostId !== deviceId) {
                   console.log('ğŸš¨ FORCE HOST CHECK: Setting correct host status')
                   setHostId(existingHostId)
                   setProtectedHost(false)
                   setHostLocked(true)
                 }
               }
             })
           }
         }
         
         // Currency configuration
         const currencySymbols = {
           USD: '$',
           EUR: 'â‚¬',
           NIS: 'â‚ª'
         }
         
         const getCurrencySymbol = () => currencySymbols[currency] || '$'
          
          // Fullscreen state
          const [isFullscreen, setIsFullscreen] = useState(false)
         
         // Timer refs
         const intervalRef = useRef(null)
         const breakIntervalRef = useRef(null)
         const elapsedIntervalRef = useRef(null)
         const audioRef = useRef(null)
         
         // Firebase real-time database functions
         const getCurrentRoomId = () => {
           const currentId = window.roomId || roomId
           if (!currentId) {
             console.warn('âš ï¸ No room ID available')
           }
           return currentId
         }
         
         const syncGameState = (gameData) => {
           try {
             const currentRoomId = getCurrentRoomId()
             if (!currentRoomId) {
               console.warn('âš ï¸ No room ID available, skipping sync')
               return
             }
             
             const gameStateRef = database.ref(`rooms/${currentRoomId}/gameState`)
             
             // Include ALL important game state in the sync
             const fullGameState = {
               ...gameData,
               // Always include these core parameters
               numPlayers,
               maxRebuys,
               addonTime,
               numWinners,
               buyInPrice,
               rebuyPrice,
               currency,
               levels,
               minutesPerLevel,
               timeFormat,
               timePerLevelMMSS,
               prizePool,
               ratioInput,
               hostId,
               lastUpdated: Date.now(),
               updatedBy: deviceId // Use device ID instead of 'local' for better tracking
             }
             
             console.log('ğŸ”„ Syncing to room:', currentRoomId, 'with data:', fullGameState)
             console.log('ğŸ“¤ Firebase sync details:', {
               roomId: currentRoomId,
               updatedBy: fullGameState.updatedBy,
               rebuyCounts: fullGameState.rebuyCounts,
               eliminatedIds: fullGameState.eliminatedIds,
               timestamp: fullGameState.lastUpdated
             })
             gameStateRef.set(fullGameState)
           } catch (error) {
             console.error('âŒ Error syncing to Firebase:', error)
           }
         }
         
         const listenToGameUpdates = () => {
           const currentRoomId = getCurrentRoomId()
           if (!currentRoomId) {
             console.log('âš ï¸ No room ID available for listener')
             return
           }
           
           // Clean up any existing listeners first
           const existingRef = database.ref(`rooms/${currentRoomId}/gameState`)
           existingRef.off()
           
           console.log('ğŸ§ Setting up listener for room:', currentRoomId)
           const gameStateRef = database.ref(`rooms/${currentRoomId}/gameState`)
           gameStateRef.on('value', (snapshot) => {
             const data = snapshot.val()
             
             // ALWAYS check host status regardless of update source (but respect host lock)
             if (data && data.hostId !== undefined && !hostLocked) {
               const correctHostId = data.hostId
               setHostId(correctHostId)
               const shouldBeHost = correctHostId === deviceId
               setProtectedHost(shouldBeHost)
               
               // If this device thinks it's host but shouldn't be, log it
               if (isHost && !shouldBeHost) {
                 console.log('ğŸš¨ HOST OVERRIDE: This device was incorrectly host, now corrected to guest')
               }
               
               console.log('ğŸ‘‘ Host status updated:', correctHostId, 'This device is host:', shouldBeHost)
             }
             
             // Process ALL updates, but be smart about preventing infinite loops
             if (data) {
               const isFromThisDevice = data.updatedBy === deviceId
               
               // Log all updates for debugging
               console.log('ğŸ”„ Database update received:', {
                 updatedBy: data.updatedBy,
                 isFromThisDevice,
                 deviceId
               })
               
               // Update local state with ALL changes (except host status which is handled above)
               if (!isFromThisDevice) {
                 console.log('âœ… Processing update from:', data.updatedBy)
                 
                 // Update local state with remote changes
                 setLastUpdateTime(data.lastUpdated)
                 
                 // Core game state
                 if (data.players) {
                   console.log('ğŸ”„ Updating players:', data.players)
                   setPlayers(data.players)
                 }
                 if (data.eliminatedIds) {
                   console.log('ğŸ”„ Updating eliminated IDs:', data.eliminatedIds, 'from:', data.updatedBy)
                   setEliminatedIds(data.eliminatedIds)
                 }
                 if (data.rebuyCounts) {
                   console.log('ğŸ”„ Updating rebuy counts:', data.rebuyCounts, 'from:', data.updatedBy)
                   setRebuyCounts(data.rebuyCounts)
                 }
                 if (data.currentLevelIndex !== undefined) setCurrentLevelIndex(data.currentLevelIndex)
                 if (data.remainingSeconds !== undefined) setRemainingSeconds(data.remainingSeconds)
                 if (data.isRunning !== undefined) setIsRunning(data.isRunning)
                 if (data.gameStarted !== undefined) setGameStarted(data.gameStarted)
                 if (data.breakSeconds !== undefined) setBreakSeconds(data.breakSeconds)
                 if (data.isOnBreak !== undefined) setIsOnBreak(data.isOnBreak)
                 if (data.addonBreakTriggered !== undefined) setAddonBreakTriggered(data.addonBreakTriggered)
                 if (data.addonBreakPending !== undefined) setAddonBreakPending(data.addonBreakPending)
                 if (data.spotifyUrl !== undefined) setSpotifyUrl(data.spotifyUrl)
                 if (data.currentTrack !== undefined) setCurrentTrack(data.currentTrack)
                 
                 // Tournament settings
                 if (data.numPlayers !== undefined) setNumPlayers(data.numPlayers)
                 if (data.maxRebuys !== undefined) setMaxRebuys(data.maxRebuys)
                 if (data.addonTime !== undefined) setAddonTime(data.addonTime)
                 if (data.numWinners !== undefined) setNumWinners(data.numWinners)
                 if (data.buyInPrice !== undefined) setBuyInPrice(data.buyInPrice)
                 if (data.rebuyPrice !== undefined) setRebuyPrice(data.rebuyPrice)
                 if (data.currency !== undefined) setCurrency(data.currency)
                 
                 // Blind levels
                 if (data.levels) setLevels(data.levels)
                 
                 // Timer settings
                 if (data.minutesPerLevel !== undefined) setMinutesPerLevel(data.minutesPerLevel)
                 if (data.timeFormat !== undefined) setTimeFormat(data.timeFormat)
                 if (data.timePerLevelMMSS !== undefined) setTimePerLevelMMSS(data.timePerLevelMMSS)
                 
                 // Prize calculator
                 if (data.prizePool !== undefined) setPrizePool(data.prizePool)
                 if (data.ratioInput !== undefined) setRatioInput(data.ratioInput)
               } else {
                 console.log('â­ï¸ Skipping update from this device to prevent infinite loop')
               }
             }
           })
         }
         
         const updateConnectionStatus = () => {
           const connectedRef = database.ref('.info/connected')
           connectedRef.on('value', (snap) => {
             const connected = snap.val()
             setIsConnected(connected)
             
             // Update UI
             const statusElement = document.getElementById('connectionStatus')
             if (statusElement) {
               if (connected) {
                 statusElement.className = 'bg-green-600 px-3 py-2 rounded-lg text-sm'
                 statusElement.innerHTML = '<span>Connected</span>'
                 
                 // Update room display
                 const roomElement = document.querySelector('[data-room-id]')
                 if (roomElement) {
                   roomElement.textContent = `Room: ${roomId}`
                 }
               } else {
                 statusElement.className = 'bg-red-600 px-3 py-2 rounded-lg text-sm'
                 statusElement.innerHTML = '<span>Disconnected</span>'
               }
             }
           })
         }
         
         const handleJoinRoomFromStart = () => {
           if (!joinRoomCode.trim() || joinRoomCode.length !== 6) {
             alert(t.enterValidRoomCode)
             return
           }
           
           // Join the room and unlock the app
           joinRoom()
           setIsAppUnlocked(true)
           setShowAppLogin(false)
           setSelectedAction(null)
           setJoinRoomCode('')
         }
         
         const joinRoom = () => {
           if (!joinRoomCode.trim() || joinRoomCode.length !== 6) {
             alert(t.enterValidRoomCode)
             return
           }
           
           const newRoomId = joinRoomCode.toUpperCase()
           
           // First, disconnect from current room
           const currentRoomId = getCurrentRoomId()
           if (currentRoomId) {
             const currentGameStateRef = database.ref(`rooms/${currentRoomId}/gameState`)
             currentGameStateRef.off()
           }
           
           // Update the global roomId
           window.roomId = newRoomId
           
           // Update local state
           setJoinRoomCode('')
           
           // IMPORTANT: When joining a room, we are NEVER the host
           // Only the first device to create a room becomes the host
           setProtectedHost(false)
           setHostLocked(true) // Lock immediately when joining
           setIsJoiningRoom(true)
           console.log('ğŸšª Joining room as guest, not host - HOST LOCKED IMMEDIATELY')
           
           // Reconnect to the new room
           const gameStateRef = database.ref(`rooms/${newRoomId}/gameState`)
           
           // Force immediate host status check
           forceHostStatusCheck()
           
           // Get initial room data (one-time read)
           gameStateRef.once('value', (snapshot) => {
             const data = snapshot.val()
             
             // IMMEDIATE host check when joining room - ALWAYS run this
             if (data && data.hostId !== undefined) {
               const correctHostId = data.hostId
               setHostId(correctHostId)
               setProtectedHost(false) // Always false when joining existing room
               setHostLocked(true) // Lock host status - no more changes
               console.log('ğŸš¨ IMMEDIATE HOST CHECK: Host exists:', correctHostId, 'This device is guest - HOST LOCKED')
             } else if (data) {
               // Even if no hostId, if there's any data, this is an existing room
               // Force this device to be a guest
               setProtectedHost(false)
               setHostLocked(true)
               console.log('ğŸš¨ FORCE GUEST: Room has data but no hostId - locking as guest')
             }
             
             if (data) {
               console.log(`ğŸ® Joining room ${newRoomId} with data:`, data)
               
               // Update ALL game state variables
               if (data.players) {
                 setPlayers(data.players)
                 // Also update numPlayers to match the players array length
                 setNumPlayers(data.players.length)
               }
               if (data.eliminatedIds) setEliminatedIds(data.eliminatedIds)
               if (data.rebuyCounts) setRebuyCounts(data.rebuyCounts)
               if (data.currentLevelIndex !== undefined) setCurrentLevelIndex(data.currentLevelIndex)
               if (data.remainingSeconds !== undefined) setRemainingSeconds(data.remainingSeconds)
               if (data.isRunning !== undefined) setIsRunning(data.isRunning)
               if (data.gameStarted !== undefined) setGameStarted(data.gameStarted)
               if (data.breakSeconds !== undefined) setBreakSeconds(data.breakSeconds)
               if (data.isOnBreak !== undefined) setIsOnBreak(data.isOnBreak)
               if (data.addonBreakTriggered !== undefined) setAddonBreakTriggered(data.addonBreakTriggered)
               if (data.addonBreakPending !== undefined) setAddonBreakPending(data.addonBreakPending)
               if (data.spotifyUrl !== undefined) setSpotifyUrl(data.spotifyUrl)
               if (data.currentTrack !== undefined) setCurrentTrack(data.currentTrack)
               
               // Update tournament settings
               if (data.maxRebuys !== undefined) setMaxRebuys(data.maxRebuys)
               if (data.addonTime !== undefined) setAddonTime(data.addonTime)
               if (data.numWinners !== undefined) setNumWinners(data.numWinners)
               if (data.buyInPrice !== undefined) setBuyInPrice(data.buyInPrice)
               if (data.rebuyPrice !== undefined) setRebuyPrice(data.rebuyPrice)
               if (data.currency !== undefined) setCurrency(data.currency)
               
               // Update blind levels
               if (data.levels) setLevels(data.levels)
               
               // Update timer settings
               if (data.minutesPerLevel !== undefined) setMinutesPerLevel(data.minutesPerLevel)
               if (data.timeFormat !== undefined) setTimeFormat(data.timeFormat)
               if (data.timePerLevelMMSS !== undefined) setTimePerLevelMMSS(data.timePerLevelMMSS)
               
               // Update prize calculator
               if (data.prizePool !== undefined) setPrizePool(data.prizePool)
               if (data.ratioInput !== undefined) setRatioInput(data.ratioInput)
               
               // Host information - when joining, we are NEVER the host
               if (data.hostId !== undefined) {
                 setHostId(data.hostId)
                 setProtectedHost(false) // Always false when joining
                 console.log('ğŸ‘‘ Host detected:', data.hostId, 'This device is guest (not host)')
               } else {
                 // If no host is set, this device becomes the host (only for empty rooms)
                 setHostId(deviceId)
                 setProtectedHost(true)
                 console.log('ğŸ‘‘ No host found, this device becomes host for empty room:', deviceId)
               }
               
               console.log(`ğŸ® Joined room ${newRoomId} successfully!`)
               setIsJoiningRoom(false) // Reset joining flag
               
               // Set up the listener for ongoing updates in this room
               listenToGameUpdates()
             } else {
               console.log(`ğŸ  Room ${newRoomId} is empty - starting fresh game`)
               // Reset to default state for empty room
               setPlayers(Array.from({ length: 6 }, (_, i) => ({ 
                 id: i + 1, 
                 name: t.playerPlaceholder(i + 1)
               })))
               setNumPlayers(6)
               setEliminatedIds([])
               setRebuyCounts({})
               setCurrentLevelIndex(0)
               setRemainingSeconds(600)
               setGameStarted(false)
               setIsRunning(false)
               setBreakSeconds(0)
               setIsOnBreak(false)
               setAddonBreakTriggered(false)
               setAddonBreakPending(false)
               
                                // For empty rooms, the joining device becomes the host
                 setHostId(deviceId)
                 setProtectedHost(true)
                 console.log('ğŸ‘‘ Empty room - this device becomes host:', deviceId)
             }
           })
           
           // Update the room display
           const roomElement = document.querySelector('[data-room-id]')
           if (roomElement) {
             roomElement.textContent = `Room: ${newRoomId}`
           }
           
           // Clear the input field
           setJoinRoomCode('')
         }
         
                   // Load saved game state on component mount
         useEffect(() => {
            // Don't automatically restore saved state on mount
            // Let the user choose what to do via the start window
         }, [])
         
         // Initialize Firebase listeners
         useEffect(() => {
           // Start listening to game updates
           listenToGameUpdates()
           
           // Monitor connection status
           updateConnectionStatus()
           
           // Initialize host for this room
         const initializeHost = () => {
           const currentRoomId = getCurrentRoomId()
           if (currentRoomId && !isJoiningRoom) {
             // Check if this room already has a host
             const hostRef = database.ref(`rooms/${currentRoomId}/gameState/hostId`)
             hostRef.once('value', (snapshot) => {
               if (!snapshot.exists()) {
                 // No host exists, this device becomes the host
                 setHostId(deviceId)
                 setProtectedHost(true)
                 setHostLocked(false) // Allow host changes for room creator
                 console.log('ğŸ‘‘ This device is now the host')
                 
                 // IMMEDIATELY sync the host information to prevent race conditions
                 const hostData = {
                   hostId: deviceId,
                   lastUpdated: Date.now(),
                   updatedBy: deviceId
                 }
                 
                 // Write host ID directly to prevent other devices from becoming host
                 database.ref(`rooms/${currentRoomId}/gameState`).update(hostData)
                 console.log('ğŸš€ Host ID written to database immediately')
                 
                 // Then sync the full game state
                 syncGameState({
                   isRunning,
                   gameStarted,
                   players,
                   eliminatedIds,
                   rebuyCounts,
                   currentLevelIndex,
                   remainingSeconds,
                   breakSeconds,
                   isOnBreak,
                   addonBreakTriggered,
                   addonBreakPending,
                   spotifyUrl,
                   currentTrack
                 })
               } else {
                 // Host already exists, this device is NOT the host
                 const existingHostId = snapshot.val()
                 setHostId(existingHostId)
                 setProtectedHost(false)
                 setHostLocked(true) // Lock host status
                 console.log('ğŸ‘‘ Host already exists:', existingHostId, 'This device is NOT the host - HOST LOCKED')
               }
             })
           }
         }
           
                    // Initialize host after a short delay
         setTimeout(initializeHost, 500)
         
         // Cleanup listeners on unmount
           return () => {
             const currentRoomId = getCurrentRoomId()
             const gameStateRef = database.ref(`rooms/${currentRoomId}/gameState`)
             gameStateRef.off()
             
             const connectedRef = database.ref('.info/connected')
             const hostRef = database.ref(`rooms/${currentRoomId}/gameState/hostId`)
             hostRef.off()
             
             connectedRef.off()
           }
         }, [roomId]) // Re-run when room changes
         
         // Global host protection - ensure guests can never become host
         useEffect(() => {
           enforceHostProtection()
         })
         
         // Handle numPlayers changes and update players array (fallback for external changes)
         useEffect(() => {
           // Only run this if we haven't manually handled the change in updateNumPlayers
           // This is mainly for when joining rooms or restoring from saved state
           if (players.length !== numPlayers && !gameStarted && numPlayers >= 2 && numPlayers <= 20 && !isUpdatingPlayers) {
             try {
               console.log('ğŸ”„ useEffect: Adjusting players array from', players.length, 'to', numPlayers)
               
               if (players.length < numPlayers) {
                 // Add new players
                 const newPlayers = [...players]
                 for (let i = players.length; i < numPlayers; i++) {
                   newPlayers.push({ 
                     id: i + 1, 
                     name: t.playerPlaceholder(i + 1)
                   })
                 }
                 setPlayers(newPlayers)
                 console.log('âœ… useEffect: Added', numPlayers - players.length, 'new players')
               } else if (players.length > numPlayers) {
                 // Remove excess players
                 const newPlayers = players.slice(0, numPlayers)
                 setPlayers(newPlayers)
                 
                 // Also remove rebuys and eliminated status for removed players
                 const newRebuyCounts = { ...rebuyCounts }
                 const newEliminatedIds = [...eliminatedIds]
                 
                 for (let i = numPlayers; i < players.length; i++) {
                   delete newRebuyCounts[i + 1]
                   newEliminatedIds = newEliminatedIds.filter(id => id !== i + 1)
                 }
                 
                 setRebuyCounts(newRebuyCounts)
                 setEliminatedIds(newEliminatedIds)
                 console.log('âœ… useEffect: Removed', players.length - numPlayers, 'excess players')
               }
             } catch (error) {
               console.error('âŒ useEffect: Error updating players array:', error)
               // Fallback: reset to safe state
               const fallbackPlayers = Array.from({ length: numPlayers }, (_, i) => ({ 
                 id: i + 1, 
                 name: t.playerPlaceholder(i + 1)
               }))
               setPlayers(fallbackPlayers)
               console.log('ğŸ”„ useEffect: Reset to fallback state with', numPlayers, 'players')
             }
           }
         }, [numPlayers, gameStarted]) // Removed players.length from dependencies to prevent loops
         
         // Reset the updating flag when players array changes
         useEffect(() => {
           if (isUpdatingPlayers) {
             // Reset the flag after a short delay to allow state updates to complete
             const timer = setTimeout(() => {
               setIsUpdatingPlayers(false)
               console.log('âœ… Reset isUpdatingPlayers flag')
             }, 100)
             return () => clearTimeout(timer)
           }
         }, [players.length, isUpdatingPlayers])
         
         // Load user default blind levels on component mount
         useEffect(() => {
           const savedUserDefaults = localStorage.getItem('userDefaultBlindLevels')
           if (savedUserDefaults) {
             try {
               const parsed = JSON.parse(savedUserDefaults)
               setUserDefaultLevels(parsed)
              } catch (error) {
               console.error('Error loading user default blind levels:', error)
              }
            }
         }, [])
          

         
         // Current level
         const currentLevel = levels[currentLevelIndex]
         
         // Language dictionary
         const dict = useMemo(() => ({
           he: {
             title: '× ×™×”×•×œ ×¤×•×§×¨',
             tableTitle: '×©×•×œ×—×Ÿ ×•×©×—×§× ×™×',
             tournamentTitle: '× ×™×”×•×œ ×˜×•×¨× ×™×¨',
             playersCount: '××¡×¤×¨ ×©×—×§× ×™×:',
             randomSeating: '×¡×™×“×•×¨ ××§×¨××™',
             seat: '××•×©×‘',
             playerPlaceholder: (n) => `×©×—×§×Ÿ ${n}`,
             currentLevel: '×¨××” × ×•×›×—×™×ª',
             nextLevel: '×¨××” ×”×‘××”:',
             timer: '×˜×™×™××¨',
             levelTime: '×–××Ÿ ×œ×©×œ×‘:',
             minutes: '×“×§×•×ª',
             mmss: '×“×§×•×ª:×©× ×™×•×ª',
             sound: '×¦×œ×™×œ',
             smallBlind: 'Small Blind',
             bigBlind: 'Big Blind',
             breakTimer: '×˜×™×™××¨ ×”×¤×¡×§×”',
             totalTime: '×¡×”"×› ×–××Ÿ',
             automaticBreak: '×”×¤×¡×§×” ××•×˜×•××˜×™×ª ×›×œ (×“×§×•×ª)',
             off: '×›×‘×•×™',
             addonIn: 'Addon ×‘×¢×•×“ ',
             levelsTitle: '× ×™×”×•×œ ×¨××•×ª ×‘×œ×™×™× ×“×™×',
             level: '×¨××”',
             addLevel: '×”×•×¡×£ ×¨××”',
             resetDefaults: '××™×¤×•×¡ ×œ×‘×¨×™×¨×•×ª ××—×“×œ',
             saveUserDefaults: '×©××•×¨ ×›×‘×¨×™×¨×ª ××—×“×œ ××™×©×™×ª',
             restoreUserDefaults: '×©×—×–×¨ ×‘×¨×™×¨×ª ××—×“×œ ××™×©×™×ª',
             clearUserDefaults: '××—×§ ×‘×¨×™×¨×•×ª ××—×“×œ ××™×©×™×•×ª',
             exitAdmin: '×™×¦×™××” ×× ×™×”×•×œ',
             tournamentSettings: '×”×’×“×¨×•×ª ×˜×•×¨× ×™×¨',
             maxRebuys: '××§×¡×™××•× Rebuys',
             addonTime: '×©×¢×ª Addon ',
             numWinners: '××¡×¤×¨ ×× ×¦×—×™×',
             prizeCalculator: '××—×©×‘×•×Ÿ ×¤×¨×¡×™×',
             prizePool: '×¡×›×•× ×¤×¨×¡×™× ×›×•×œ×œ',
             ratioLabel: '×™×—×¡ ×—×œ×•×§×” (×œ××©×œ 50/30/20)',
             firstPlace: '××§×•× ×¨××©×•×Ÿ',
             secondPlace: '××§×•× ×©× ×™',
             thirdPlace: '××§×•× ×©×œ×™×©×™',
             howToUse: '××™×š ×œ×”×©×ª××© ×‘××¤×œ×™×§×¦×™×”',
             tournamentTab: '×›×¨×˜×™×¡ ×˜×•×¨× ×™×¨',
             tournamentTabDesc1: 'â€¢ × ×™×”×•×œ ×©×—×§× ×™×, ×˜×™×™××¨×™× ×•×”×ª×§×“××•×ª ×”××©×—×§',
             tournamentTabDesc2: 'â€¢ ×”×’×“×¨×ª ×¨××•×ª ×‘×œ×™×™× ×“×™× ×•××¢×§×‘ ××—×¨ ×—×™×¡×•×œ×™×',
             tournamentTabDesc3: 'â€¢ ×©×œ×™×˜×” ×‘×”×¤×¡×§×•×ª ×•×”×’×“×¨×•×ª ×”×¤×¡×§×” ××•×˜×•××˜×™×ª',
             prizeCalculator: '××—×©×‘×•×Ÿ ×¤×¨×¡×™×',
             prizeCalculatorDesc1: 'â€¢ ×—×™×©×•×‘ ×—×œ×•×§×ª ×¤×¨×¡×™×',
             prizeCalculatorDesc2: 'â€¢ ×”×’×“×¨×ª ×™×—×¡×™× ××•×ª×××™× ×œ×›×œ ××¡×¤×¨ ×× ×¦×—×™×',
             prizeCalculatorDesc3: 'â€¢ ××™×Ÿ ×¦×•×¨×š ×‘×¡×™×¡××” - ×’×™×©×” ×¦×™×‘×•×¨×™×ª',
             adminSettings: '×”×’×“×¨×•×ª ×× ×”×œ',
             adminSettingsDesc1: 'â€¢ ×”×’×“×¨×ª ×—×•×§×™ ×”×˜×•×¨× ×™×¨',
             adminSettingsDesc2: 'â€¢ ×”×’×“×¨×ª ××§×¡×™××•× rebuys ×•×©×¢×ª addon',
             adminSettingsDesc3: 'â€¢ ×’×™×©×” ××•×’×‘×œ×ª ×œ×× ×”×œ×™× ×‘×œ×‘×“',
             newGame: '××©×—×§ ×—×“×©',
             newGameDesc1: 'â€¢ ××™×¤×•×¡ ×”×›×œ ×œ×˜×•×¨× ×™×¨×™× ×—×“×©×™×',
             newGameDesc2: 'â€¢ ××¦×‘ ××¡×š ××œ× ×œ×ª×¦×•×’×” ×˜×•×‘×” ×™×•×ª×¨',
             newGameDesc3: 'â€¢ ×©××™×¨×” ××•×˜×•××˜×™×ª ×©×œ ×”×ª×§×“××•×ª',
             appPassword: '×¡×™×¡××ª ××¤×œ×™×§×¦×™×”',
             enterPassword: '×”×›× ×¡ ×¡×™×¡××”',
             unlock: '×¤×ª×—',
             cancel: '×‘×™×˜×•×œ',
             welcomeMessage: '×‘×¨×•×›×™× ×”×‘××™× ×œ×× ×”×œ ×˜×•×¨× ×™×¨ ×¤×•×§×¨',
             chooseLanguage: '×‘×—×¨ ×©×¤×”',
             continueLastGame: '×”××©×š ××©×—×§ ××—×¨×•×Ÿ',
             startNewGame: '××©×—×§ ×—×“×©',
             noSavedGame: '×œ× × ××¦× ××©×—×§ ×©××•×¨',
             savedGameInfo: '× ××¦× ××©×—×§ ×©××•×¨ ×',
             savedGameDetails: '×©×—×§× ×™×, ×¨××”',
             
             // New translations for untranslated text
             buyInPrice: '××—×™×¨ ×›× ×™×¡×”',
             rebuyPrice: '××—×™×¨ ×¨×›×™×©×” ×—×•×–×¨×ª',
             currency: '××˜×‘×¢',
             winnersHelper: '××¡×¤×¨ ×”×©×—×§× ×™× ×©×™×§×‘×œ×• ×¤×¨×¡×™×',
             addonTimeHelper: '×”×©×ª××© ×‘×¤×•×¨××˜ 24 ×©×¢×•×ª (×©×¢×”:×“×§×•×ª). ×”×©××¨ ×¨×™×§ ×œ×‘×™×˜×•×œ. ×“×•×’××”: 20:30 ×œ-8:30 ×‘×¢×¨×‘',
             rebuysHelper: '×”×’×“×¨ ×œ-0 ×œ×‘×™×˜×•×œ ×¨×›×™×©×•×ª ×—×•×–×¨×•×ª',
             buyInHelper: '××—×™×¨ ×œ×›×œ ×©×—×§×Ÿ ×œ×”×™×›× ×¡ ×œ×˜×•×¨× ×™×¨',
             rebuyHelper: '××—×™×¨ ×œ×›×œ ×¨×›×™×©×” ×—×•×–×¨×ª (×–×”×” ×œ××—×™×¨ ×›× ×™×¡×” ×›×‘×¨×™×¨×ª ××—×“×œ)',
             currencyHelper: '×‘×—×¨ ××ª ×”××˜×‘×¢ ×œ××—×™×¨×™ ×”×˜×•×¨× ×™×¨',
             clearSavedGame: '× ×§×” ××©×—×§ ×©××•×¨',
             resetPlayers: '××¤×¡ ×©×—×§× ×™×',
             clearGameHelper: '×–×” ×™×¡×™×¨ ××ª ×›×œ ×”×”×ª×§×“××•×ª ×”×©××•×¨×” ×•×™×¤×¢×™×œ ××—×“×© ××ª ×”××¤×œ×™×§×¦×™×”',
             resetPlayersHelper: '×–×” ×™××¤×¡ ×©××•×ª ×©×—×§× ×™×, ×¨×›×™×©×•×ª ×—×•×–×¨×•×ª ×•×¡×˜×˜×•×¡ ×—×™×¡×•×œ ×ª×•×š ×©××™×¨×” ×¢×œ ×”×ª×§×“××•×ª ×”×˜×•×¨× ×™×¨',
             fullscreen: '××¡×š ××œ×',
             exitFullscreen: '×¦× ×××¡×š ××œ×',
             login: '×”×ª×—×‘×¨×•×ª',
             password: '×¡×™×¡××”:',
             buyInsLabel: '×¨×›×™×©×•×ª:',
             rebuysLabel: '×¨×›×™×©×•×ª ×—×•×–×¨×•×ª:',
             formulaExplanation: '××—×™×¨ ×›× ×™×¡×” Ã— ××¡×¤×¨ ×©×—×§× ×™× + ××—×™×¨ ×¨×›×™×©×” ×—×•×–×¨×ª Ã— ×¡×”"×› ×¨×›×™×©×•×ª ×—×•×–×¨×•×ª',
             lowestChipValue: '×¢×¨×š ×”×©×‘×‘ ×”× ××•×š ×‘×™×•×ª×¨',
             lowestChipHelper: '×”×›× ×¡ ××ª ×”×¢×¨×š ×”× ××•×š ×‘×™×•×ª×¨ ×‘×©×‘×‘×™× ×©×œ×š (×œ××©×œ: 1, 5, 10, 25)',
             generateBlinds: '×¦×•×¨ ×¨××•×ª ×‘×œ×™×™× ×“×™×',
             generateBlindsHelper: '×™×¦×•×¨ ××•×˜×•××˜×™×ª ×¨××•×ª ×‘×œ×™×™× ×“×™× ××‘×•×¡×¡×•×ª ×¢×œ ×¢×¨×š ×”×©×‘×‘ ×”× ××•×š ×‘×™×•×ª×¨',
             removeLevel: '×”×¡×¨ ×¨××”',
             removeLevelHelper: '×”×¡×¨ ××ª ×”×¨××” ×”××—×¨×•× ×” ××”×˜×•×¨× ×™×¨',
             infinite: 'âˆ',
             numberOfLevels: '××¡×¤×¨ ×¨××•×ª',
             numberOfLevelsHelper: '×”×›× ×¡ ××ª ××¡×¤×¨ ×¨××•×ª ×”×‘×œ×™×™× ×“×™× ×”×¨×¦×•×™',
             calculateLevels: '×—×©×‘ ×¨××•×ª',
             
             // Additional translations for remaining English text
             readyToStart: '?××•×›×Ÿ ×œ×”×ª×—×™×œ ××ª ×”×˜×•×¨× ×™×¨',
             startGame: '×”×ª×—×œ ××©×—×§',
             startGameLocked: '×–×” ×™× ×¢×•×œ ×©××•×ª ×©×—×§× ×™×, ××™×§×•××™× ×•××¡×¤×¨ ×©×—×§× ×™×',
             tournamentStarted: '×”×˜×•×¨× ×™×¨ ×”×ª×—×™×œ - ×”×’×“×¨×•×ª × ×¢×•×œ×•×ª',
             startGameFirst: '×”×ª×—×œ ××©×—×§ ×§×•×“×',
             reset: '××¤×¡',
             tournamentActive: '×˜×•×¨× ×™×¨ ×¤×¢×™×œ',
             tournamentSetup: '×”×’×“×¨×ª ×˜×•×¨× ×™×¨',
             maxRebuysLabel: '××§×¡×™××•× ×¨×›×™×©×•×ª ×—×•×–×¨×•×ª:',
             addonTimeLabel: '×–××Ÿ Addon:',
             addonBreakStatus: '×¡×˜×˜×•×¡ ×”×¤×¡×§×ª Addon:',
             tournamentPricing: '××—×™×¨×™ ×˜×•×¨× ×™×¨:',
             buyInLabel: '×¨×›×™×©×”:',
             rebuyLabel: '×¨×›×™×©×” ×—×•×–×¨×ª:',
             currentRebuys: '×¨×›×™×©×•×ª ×—×•×–×¨×•×ª × ×•×›×—×™×•×ª:',
             totalPrizePool: '×¡×”"×› ×¤×¨×¡×™×:',
             waitingForLevelEnd: '×××ª×™×Ÿ ×œ×¡×•×£ ×”×¨××”',
             active: '×¤×¢×™×œ',
             waiting: '×××ª×™×Ÿ',
             pause: '×”×©×”×”',
             resume: '×”××©×š',
             out: '×™×¦×',
             in: '×‘×¤× ×™×',
             locked: '× ×¢×•×œ',
             rebuys: '×¨×›×™×©×•×ª ×—×•×–×¨×•×ª:',
             maxReached: '××§×¡×™××•× ×”×’×™×¢',
             seatingLocked: '×™×©×™×‘×” × ×¢×•×œ×”',
             playerControlsLocked: '×‘×§×¨×•×ª ×”×©×—×§× ×™× ×™×™×¤×ª×—×• ×›××©×¨ ×ª×ª×—×™×œ ××ª ×”××©×—×§ ×•×ª× ×¢×•×œ ××ª ×”×’×“×¨×•×ª ×”×˜×•×¨× ×™×¨',
             applySettings: '×”×—×œ ×”×’×“×¨×•×ª',
             finalLevel: '×¨××” ××—×¨×•× ×” - ×˜×•×¨× ×™×¨ × ××©×š!',
             addonBreakPending: '×”×¤×¡×§×ª Addon ×××ª×™× ×” ×œ×¡×•×£ ×”×¨××” ×”× ×•×›×—×™×ª',
             addonIn: 'Addon ×‘×¢×•×“',
             addonTime: '×–××Ÿ Addon!',
             noAddonTimeSet: '×œ× ×”×•×’×“×¨ ×–××Ÿ Addon',
             addonBreakActive: '×”×¤×¡×§×ª Addon ×¤×¢×™×œ×”',
             addonBreakWaiting: '×”×¤×¡×§×ª Addon ×××ª×™× ×”',
             addonBreakStatusWaiting: '×××ª×™×Ÿ ×œ×¡×•×£ ×”×¨××”',
             addonBreakStatusActive: '×¤×¢×™×œ',
             addonBreakStatusWaiting: '×××ª×™×Ÿ',
             spotifyMusic: '××•×–×™×§×ª Spotify',
             setMood: '×§×‘×¢ ××ª ×”××•×•×™×¨×” ×œ×˜×•×¨× ×™×¨ ×©×œ×š',
             pasteSpotifyLink: '×”×“×‘×§ ×§×™×©×•×¨ Spotify ×œ××˜×” ×›×“×™ ×œ× ×’×Ÿ ××•×–×™×§×” ×‘××”×œ×š ×”×˜×•×¨× ×™×¨ ×©×œ×š:',
             play: 'â–¶ï¸ × ×’×Ÿ',
             enterUrl: 'ğŸ”’ ×”×›× ×¡ ×›×ª×•×‘×ª',
             pressEnter: 'ğŸ’¡ ×œ×—×¥ Enter ×œ× ×’×™× ×” ××™×™×“×™×ª',
             nowPlaying: '××ª× ×’×Ÿ ×¢×›×©×™×•',
             stop: 'ğŸ›‘ ×¢×¦×•×¨',
             musicPlaying: '××•×–×™×§×” ××ª× ×’× ×ª',
             noMusicPlaying: '×œ× ××ª× ×’× ×ª ××•×–×™×§×”',
             pasteLinkAndPlay: '×”×“×‘×§ ×§×™×©×•×¨ Spotify ×œ××¢×œ×” ×•×œ×—×¥ ×¢×œ × ×’×Ÿ ×›×“×™ ×œ×”×ª×—×™×œ',
             supportsTracks: '×ª×•××š ×‘×©×™×¨×™×, ×¨×©×™××•×ª ×”×©××¢×” ×•××œ×‘×•××™×',
             perfectForTournaments: '××•×©×œ× ×œ×˜×•×¨× ×™×¨×™×',
             todaysTopHits: '×”×œ×”×™×˜×™× ×”××•×‘×™×œ×™× ×©×œ ×”×™×•×',
             rockClassics: '×§×œ××¡×™×§×•×ª ×¨×•×§',
             chillVibes: '××•×•×™×¨×” ×¨×’×•×¢×”',
             automaticPrizeCalculation: '×—×™×©×•×‘ ×¤×¨×¡×™× ××•×˜×•××˜×™',
             prizePoolAutoCalc: '×¡×”"×› ×”×¤×¨×¡×™× ××—×•×©×‘ ××•×˜×•××˜×™×ª ×‘×”×ª×‘×¡×¡ ×¢×œ ×”×’×“×¨×•×ª ×”×˜×•×¨× ×™×¨ ×©×œ×š: ×¢×“×›×•×Ÿ ×”××—×™×¨×™× ×‘×”×’×“×¨×•×ª ×”×˜×•×¨× ×™×¨ ×œ×¨××•×ª ×©×™× ×•×™×™× ×‘×–××Ÿ ×××ª.',
             enterNumbersSeparated: '×”×›× ×¡ {numWinners} ××¡×¤×¨×™× ××•×¤×¨×“×™× ×‘- / (×œ××©×œ: {example})',
             place4th: '××§×•× 4',
             place5th: '××§×•× 5',
             place6th: '××§×•× 6',
             place7th: '××§×•× 7',
             place8th: '××§×•× 8',
             place9th: '××§×•× 9',
             place10th: '××§×•× 10',
             tournamentSetupMode: '××¦×‘ ×”×’×“×¨×•×ª ×˜×•×¨× ×™×¨',
             canStillModify: '×¢×“×™×™×Ÿ ×ª×•×›×œ ×œ×©× ×•×ª ×©××•×ª ×©×—×§× ×™×, ×™×©×™×‘×” ×•××¡×¤×¨ ×©×—×§× ×™×. ×‘×¨×’×¢ ×©×ª×œ×—×¥ ×¢×œ "×”×ª×—×œ ××©×—×§" ×‘×ª×¦×•×’×ª ×”×˜×•×¨× ×™×¨ ×”×¨××©×™×ª, ×”×’×“×¨×•×ª ××œ×” ×™×™× ×¢×œ×•.',
             tournamentActiveSettingsLocked: '×˜×•×¨× ×™×¨ ×¤×¢×™×œ - ×”×’×“×¨×•×ª × ×¢×•×œ×•×ª',
             tournamentStartedSettingsLocked: '×”×˜×•×¨× ×™×¨ ×”×ª×—×™×œ. ×©××•×ª ×©×—×§× ×™×, ×™×©×™×‘×” ×•××¡×¤×¨ ×©×—×§× ×™× ×›×¢×ª × ×¢×•×œ×™× ×œ×©×œ××•×ª.',
             addonTimeInPast: '×–××Ÿ Addon ×‘×¢×‘×¨ - ×©× ×” ×œ×©×¢×” ×¢×ª×™×“×™×ª',
             addonTimeValid: '×–××Ÿ Addon ×ª×§×™×Ÿ',
             cannotStartWithPastAddon: '×œ× × ×™×ª×Ÿ ×œ×”×ª×—×™×œ ××©×—×§ ×¢× ×–××Ÿ Addon ×‘×¢×‘×¨. ×©× ×” ××ª ×”×–××Ÿ ×œ×©×¢×” ×¢×ª×™×“×™×ª.',
             personalDefaultsAvailable: '×‘×¨×™×¨×•×ª ××—×“×œ ××™×©×™×•×ª ×–××™× ×•×ª',
             levels: '×¨××•×ª',
             chip: '×©×‘×‘',
             addonBreakReset: '××¤×¡ ××¦×‘ ×”×¤×¡×§×ª Addon',
             lockedUntilGameStarts: '× ×¢×•×œ ×¢×“ ×ª×—×™×œ×ª ×”××©×—×§',
             testAddonBreak: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystem: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakHelper: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelper: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelperText: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelperText2: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelperText3: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelperText4: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelperText5: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelperText6: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelperText7: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelperText8: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelperText9: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             testAddonBreakSystemHelperText10: '×‘×“×•×§ ××¢×¨×›×ª ×”×¤×¡×§×ª Addon',
             enterPasswordForNewGame: '×”×›× ×¡ ×¡×™×¡××” ×œ××©×—×§ ×—×“×©:',
             enterPasswordForSavedGame: '×”×›× ×¡ ×¡×™×¡××” ×œ××©×—×§ ×”×©××•×¨:',
             newGameReady: '××©×—×§ ×—×“×© ××•×›×Ÿ! ×”×›× ×¡ ×¡×™×¡××” ×›×“×™ ×œ×”×ª×—×™×œ.',
             confirmNewGame: '×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×”×ª×—×™×œ ××©×—×§ ×—×“×©? ×–×” ×™××¤×¡ ×”×›×œ ×œ×¢×¨×›×™× ×‘×¨×™×¨×ª ××—×“×œ.',
             confirmClearSavedGame: '×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ× ×§×•×ª ××ª ×”××©×—×§ ×”×©××•×¨? ×œ× × ×™×ª×Ÿ ×œ×‘×˜×œ ×¤×¢×•×œ×” ×–×•.',
             confirmResetPlayers: '×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××¤×¡ ××ª ×›×œ ×”×©×—×§× ×™×? ×–×” ×™× ×§×” ×©××•×ª, ×¨×›×™×©×•×ª ×—×•×–×¨×•×ª ×•×¡×˜×˜×•×¡ ×—×™×¡×•×œ.',
             confirmResetAddonBreak: '×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××¤×¡ ××ª ××¦×‘ ×”×¤×¡×§×ª Addon? ×–×” ×™××¤×©×¨ ×œ×”×¤×¢×™×œ ××—×“×© ××ª ×”×¤×¡×§×ª Addon.',
             confirmTestAddonBreak: '×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×‘×“×•×§ ××ª ××¢×¨×›×ª ×”×¤×¡×§×ª Addon? ×–×” ×™××ª×—×œ ×”×¤×¡×§×” ×©×œ 15 ×“×§×•×ª.',
             incorrectPassword: '×¡×™×¡××” ×©×’×•×™×”!',
             errorReadingSavedGame: '×©×’×™××” ×‘×§×¨×™××ª ×”××©×—×§ ×”×©××•×¨',
             pleaseEnterValidSpotifyUrl: '×× × ×”×›× ×¡ ×›×ª×•×‘×ª Spotify ×ª×§×™× ×”',
             addonTimePastError: '×©×’×™××”: ×–××Ÿ Addon ×©×”×•×’×“×¨ ×”×•× ×‘×¢×‘×¨. ×× × ×©× ×” ××ª ×–××Ÿ Addon ×œ×©×¢×” ×¢×ª×™×“×™×ª ×œ×¤× ×™ ×”×ª×—×œ×ª ×”××©×—×§.',
             addonTimeReached: '×–××Ÿ Addon ×”×’×™×¢! ×”×¤×¡×§×” ×©×œ 15 ×“×§×•×ª ×ª×ª×—×™×œ ×‘×¡×•×£ ×”×¨××” ×”× ×•×›×—×™×ª.',
             addonBreakStartingNow: '×”×¤×¡×§×ª Addon ×©×œ 15 ×“×§×•×ª ××ª×—×™×œ×” ×¢×›×©×™×•!',
             confirmStartGame: '×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×”×ª×—×™×œ ××ª ×”××©×—×§? ×–×” ×™× ×¢×•×œ ×©××•×ª ×©×—×§× ×™×, ××™×§×•××™× ×•××¡×¤×¨ ×©×—×§× ×™× ×œ××©×š ×”×˜×•×¨× ×™×¨.',
             chipValueMustBeGreaterThanZero: '×¢×¨×š ×”×©×‘×‘ ×—×™×™×‘ ×œ×”×™×•×ª ×’×“×•×œ ×-0',
             numberOfLevelsMustBeGreaterThanZero: '××¡×¤×¨ ×”×¨××•×ª ×—×™×™×‘ ×œ×”×™×•×ª ×’×“×•×œ ×-0',
             blindLevelListSavedAsPersonalDefault: '×¨×©×™××ª ×¨××•×ª ×”×‘×œ×™×™× ×“ × ×©××¨×” ×›×‘×¨×™×¨×ª ××—×“×œ ××™×©×™×ª!',
             personalBlindLevelListRestored: '×¨×©×™××ª ×¨××•×ª ×”×‘×œ×™×™× ×“ ×”××™×©×™×ª ×©×•×—×–×¨×”!',
             noPersonalDefaultsFound: '×œ× × ××¦××• ×‘×¨×™×¨×•×ª ××—×“×œ ××™×©×™×•×ª. ×©××•×¨ ×§×•×“× ×¨×©×™××ª ×¨××•×ª ×›×‘×¨×™×¨×ª ××—×“×œ ××™×©×™×ª.',
             personalDefaultsCleared: '×‘×¨×™×¨×•×ª ×”××—×“×œ ×”××™×©×™×•×ª × ××—×§×•!',
             adminAccess: '×’×™×©×ª ×× ×”×œ',
             enterPasswordPlaceholder: '×”×›× ×¡ ×¡×™×¡××”',
             openRecentGame: '×¤×ª×— ××©×—×§ ××—×¨×•×Ÿ',
             joinDifferentRoom: '×”×¦×˜×¨×£ ×œ×—×“×¨ ××—×¨:',
             enterRoomCode: '×”×›× ×¡ ×§×•×“ ×—×“×¨ (×œ××©×œ ABC123)',
             joinRoom: '×”×¦×˜×¨×£ ×œ×—×“×¨',
             enterValidRoomCode: '×× × ×”×›× ×¡ ×§×•×“ ×—×“×¨ ×ª×§×™×Ÿ ×©×œ 6 ×ª×•×•×™×',
             roomCodeHelper: '×”×›× ×¡ ×§×•×“ ×—×“×¨ ×©×œ 6 ×ª×•×•×™× ×›×“×™ ×œ×”×¦×˜×¨×£ ×œ××©×—×§ ×§×™×™×',
             hostOnly: '×× ×”×œ ×‘×œ×‘×“'
           },
           en: {
             title: 'Poker Management',
             tableTitle: 'Table & Players',
             tournamentTitle: 'Tournament Management',
             playersCount: 'Players:',
             randomSeating: 'Random Seating',
             seat: 'Seat',
             playerPlaceholder: (n) => `Player ${n}`,
             currentLevel: 'Current Level',
             nextLevel: 'Next Level:',
             timer: 'Timer',
             levelTime: 'Time per level:',
             minutes: 'Minutes',
             mmss: 'MM:SS',
             sound: 'Sound',
             smallBlind: 'Small Blind',
             bigBlind: 'Big Blind',
             breakTimer: 'Break Timer',
             totalTime: 'Total Time',
             automaticBreak: 'Auto-break every (minutes)',
             off: 'Off',
              addonIn: 'Addon in',
             levelsTitle: 'Blind Levels Management',
             level: 'Level',
             addLevel: 'Add Level',
             resetDefaults: 'Reset to Defaults',
             saveUserDefaults: 'Save as Personal Default',
             restoreUserDefaults: 'Restore Personal Default',
             clearUserDefaults: 'Clear Personal Defaults',
             exitAdmin: 'Exit Admin',
              tournamentSettings: 'Tournament Settings',
              maxRebuys: 'Max Rebuys',
              addonTime: 'Addon Time (HH:MM)',
              numWinners: 'Number of Winners',
             prizeCalculator: 'Prize Calculator',
             prizePool: 'Total Prize Pool',
             ratioLabel: 'Distribution Ratio (e.g., 50/30/20)',
             firstPlace: '1st Place',
             secondPlace: '2nd Place',
              thirdPlace: '3rd Place',
             howToUse: 'How to Use This App',
             tournamentTab: 'Tournament Tab',
             tournamentTabDesc1: 'â€¢ Manage players, timers, and game progress',
             tournamentTabDesc2: 'â€¢ Set blind levels and track eliminations',
             tournamentTabDesc3: 'â€¢ Control breaks and auto-break settings',
             prizeCalculator: 'Prize Calculator',
             prizeCalculatorDesc1: 'â€¢ Calculate prize distributions',
             prizeCalculatorDesc2: 'â€¢ Set custom ratios for any number of winners',
             prizeCalculatorDesc3: 'â€¢ No password required - public access',
             adminSettings: 'Admin Settings',
             adminSettingsDesc1: 'â€¢ Configure tournament rules',
             adminSettingsDesc2: 'â€¢ Set max rebuys and addon time',
             adminSettingsDesc3: 'â€¢ Restricted access for administrators only',
             newGame: 'New Game',
             newGameDesc1: 'â€¢ Reset everything for fresh tournaments',
             newGameDesc2: 'â€¢ Fullscreen mode for better visibility',
             newGameDesc3: 'â€¢ Auto-saves progress automatically',
             appPassword: 'App Password',
             enterPassword: 'Enter Password',
             unlock: 'Unlock',
             cancel: 'Cancel',
             welcomeMessage: 'Welcome to Poker Tournament Manager',
             chooseLanguage: 'Choose Language',
             continueLastGame: 'Continue Last Game',
             startNewGame: 'Start New Game',
             noSavedGame: 'No saved game found',
             savedGameInfo: 'Saved game found from',
             savedGameDetails: 'players, level',
             
             // New translations for untranslated text
             buyInPrice: 'Buy-in Price',
             rebuyPrice: 'Rebuy Price',
             currency: 'Currency',
             winnersHelper: 'Number of players who will receive prizes',
             addonTimeHelper: 'Use 24-hour format (HH:MM). Leave empty to disable. Example: 20:30 for 8:30 PM',
             rebuysHelper: 'Set to 0 to disable rebuys',
             buyInHelper: 'Price per player to enter the tournament',
             rebuyHelper: 'Price for each rebuy (same as buy-in by default)',
             currencyHelper: 'Select the currency for tournament pricing',
             clearSavedGame: 'Clear Saved Game',
             resetPlayers: 'Reset Players',
             clearGameHelper: 'This will remove all saved progress and restart the application',
             resetPlayersHelper: 'This will reset player names, rebuys, and eliminated status while keeping tournament progress',
             fullscreen: 'Fullscreen',
             exitFullscreen: 'Exit Fullscreen',
             login: 'Login',
             password: 'Password:',
             buyInsLabel: 'Buy-ins:',
             rebuysLabel: 'Rebuys:',
             formulaExplanation: 'Buy-in Price Ã— Number of Players + Rebuy Price Ã— Total Rebuys',
             lowestChipValue: 'Lowest Chip Value',
             lowestChipHelper: 'Enter the lowest value chip in your set (e.g., 1, 5, 10, 25)',
             generateBlinds: 'Generate Blind Levels',
             generateBlindsHelper: 'Automatically generate blind levels based on the lowest chip value',
             removeLevel: 'Remove Level',
             removeLevelHelper: 'Remove the last level from the tournament',
             infinite: 'âˆ',
             numberOfLevels: 'Number of Levels',
             numberOfLevelsHelper: 'Enter the desired number of blind levels',
             calculateLevels: 'Calculate Levels',
             
             // Additional translations for remaining English text
             readyToStart: 'Ready to start the tournament?',
             startGame: 'START GAME',
             startGameLocked: 'This will lock player names, positions, and player count',
             tournamentStarted: 'Tournament Started - Settings Locked',
             startGameFirst: 'Start Game First',
             reset: 'Reset',
             tournamentActive: 'Tournament Active',
             tournamentSetup: 'Tournament Setup',
             maxRebuysLabel: 'Max Rebuys:',
             addonTimeLabel: 'Addon Time:',
             addonBreakStatus: 'Addon Break Status:',
             tournamentPricing: 'Tournament Pricing:',
             buyInLabel: 'Buy-in:',
             rebuyLabel: 'Rebuy:',
             currentRebuys: 'Current Rebuys:',
             totalPrizePool: 'Total Prize Pool:',
             waitingForLevelEnd: 'Waiting for Level End',
             active: 'Active',
             waiting: 'Waiting',
             pause: 'Pause',
             resume: 'Resume',
             out: 'Out',
             in: 'In',
             locked: 'Locked',
             rebuys: 'Rebuys:',
             maxReached: 'Max Reached',
             seatingLocked: 'Seating Locked',
             playerControlsLocked: 'Player controls (rebuys, elimination) will be unlocked when you start the game and lock tournament settings',
             applySettings: 'Apply Settings',
             finalLevel: 'Final Level - Tournament Continues!',
             addonBreakPending: 'Addon Break Pending - End of Current Level',
             addonIn: 'Addon in',
             addonTime: 'ADDON TIME!',
             noAddonTimeSet: 'No addon time set',
             addonBreakActive: 'Addon Break Active',
             addonBreakWaiting: 'Addon Break Waiting',
             addonBreakStatusWaiting: 'Waiting for Level End',
             addonBreakStatusActive: 'Active',
             addonBreakStatusWaiting: 'Waiting',
             spotifyMusic: 'Spotify Music',
             setMood: 'Set the mood for your tournament',
             pasteSpotifyLink: 'Paste a Spotify link below to play music during your tournament:',
             play: 'â–¶ï¸ Play',
             enterUrl: 'ğŸ”’ Enter URL',
             pressEnter: 'ğŸ’¡ Press Enter to play instantly',
             nowPlaying: 'Now Playing',
             stop: 'ğŸ›‘ Stop',
             musicPlaying: 'Music is playing',
             noMusicPlaying: 'No music playing',
             pasteLinkAndPlay: 'Paste a Spotify link above and click Play to start',
             supportsTracks: 'Supports tracks, playlists & albums',
             perfectForTournaments: 'Perfect for tournaments',
             todaysTopHits: 'Today\'s Top Hits',
             rockClassics: 'Rock Classics',
             chillVibes: 'Chill Vibes',
             automaticPrizeCalculation: 'Automatic Prize Calculation',
             prizePoolAutoCalc: 'The prize pool is automatically calculated based on your tournament settings: Update the pricing in Tournament Settings to see real-time changes.',
             enterNumbersSeparated: 'Enter {numWinners} numbers separated by / (e.g., {example})',
             place4th: '4th Place',
             place5th: '5th Place',
             place6th: '6th Place',
             place7th: '7th Place',
             place8th: '8th Place',
             place9th: '9th Place',
             place10th: '10th Place',
             tournamentSetupMode: 'Tournament Setup Mode',
             canStillModify: 'You can still modify player names, seating, and player count. Once you click "Start Game" in the main tournament view, these settings will be locked.',
             tournamentActiveSettingsLocked: 'Tournament Active - Settings Locked',
             tournamentStartedSettingsLocked: 'The tournament has started. Player names, seating, and player count are now locked for integrity.',
             addonTimeInPast: 'Addon time in past - change to future time',
             addonTimeValid: 'Addon time valid',
             cannotStartWithPastAddon: 'Cannot start game with past addon time. Change the time to a future time.',
             personalDefaultsAvailable: 'Personal defaults available',
             levels: 'levels',
             chip: 'chip',
             addonBreakReset: 'Reset Addon Break',
             lockedUntilGameStarts: 'Locked until game starts',
             testAddonBreak: 'Test Addon Break',
             testAddonBreakSystem: 'Test Addon Break System',
             testAddonBreakHelper: 'Test Addon Break',
             testAddonBreakSystemHelper: 'Test Addon Break System',
             testAddonBreakSystemHelperText: 'Test Addon Break System',
             testAddonBreakSystemHelperText2: 'Test Addon Break System',
             testAddonBreakSystemHelperText3: 'Test Addon Break System',
             testAddonBreakSystemHelperText4: 'Test Addon Break System',
             testAddonBreakSystemHelperText5: 'Test Addon Break System',
             testAddonBreakSystemHelperText6: 'Test Addon Break System',
             testAddonBreakSystemHelperText7: 'Test Addon Break System',
             testAddonBreakSystemHelperText8: 'Test Addon Break System',
             testAddonBreakSystemHelperText9: 'Test Addon Break System',
             testAddonBreakSystemHelperText10: 'Test Addon Break System',
             enterPasswordForNewGame: 'Enter password for new game:',
             enterPasswordForSavedGame: 'Enter password for saved game:',
             newGameReady: 'New game ready! Enter password to start.',
             confirmNewGame: 'Are you sure you want to start a new game? This will reset everything to default values.',
             confirmClearSavedGame: 'Are you sure you want to clear the saved game? This cannot be undone.',
             confirmResetPlayers: 'Are you sure you want to reset all players? This will clear names, rebuys, and eliminated status.',
             confirmResetAddonBreak: 'Are you sure you want to reset the addon break state? This will allow the addon break to trigger again.',
             confirmTestAddonBreak: 'Are you sure you want to test the addon break system? This will start a 15-minute break.',
             incorrectPassword: 'Incorrect password!',
             errorReadingSavedGame: 'Error reading saved game',
             pleaseEnterValidSpotifyUrl: 'Please enter a valid Spotify URL',
             addonTimePastError: 'Error: The addon time you set is in the past. Please change the addon time to a future time before starting the game.',
             addonTimeReached: 'Addon time reached! 15-minute break will start when current level ends.',
             addonBreakStartingNow: 'Addon break of 15 minutes starting now!',
             confirmStartGame: 'Are you sure you want to start the game? This will lock player names, positions, and player count for the duration of the tournament.',
             chipValueMustBeGreaterThanZero: 'Chip value must be greater than 0',
             numberOfLevelsMustBeGreaterThanZero: 'Number of levels must be greater than 0',
             blindLevelListSavedAsPersonalDefault: 'Blind level list saved as personal default!',
             personalBlindLevelListRestored: 'Personal blind level list restored!',
             noPersonalDefaultsFound: 'No personal defaults found. Save a blind level list as personal default first.',
             personalDefaultsCleared: 'Personal defaults cleared!',
             adminAccess: 'Admin Access',
             enterPasswordPlaceholder: 'Enter password',
             openRecentGame: 'Open Recent Game',
             joinDifferentRoom: 'Join Different Room:',
             enterRoomCode: 'Enter room code (e.g., ABC123)',
             joinRoom: 'Join Room',
             enterValidRoomCode: 'Please enter a valid 6-character room code',
             roomCodeHelper: 'Enter a 6-character room code to join an existing game',
             hostOnly: 'Host Only'
           }
         }), [])
         
         const t = dict[lang]
        
                 // Helper function to get time per level in seconds
         function getTimePerLevelInSeconds() {
           if (timeFormat === 'minutes') {
             return minutesPerLevel * 60
           } else {
             // Parse MM:SS format
             const [minutes, seconds] = timePerLevelMMSS.split(':').map(Number)
             return (minutes * 60) + (seconds || 0)
           }
         }
         
         // Helper function to check if addon time is valid (not in the past)
         function isAddonTimeValid() {
           if (!addonTime) return true // No addon time set is considered valid
           
           const now = new Date()
           const currentHour = now.getHours()
           const currentMinute = now.getMinutes()
           const [targetHour, targetMinute] = addonTime.split(':').map(Number)
           
           if (targetHour === undefined || targetMinute === undefined) return false
           
           const currentTotalMinutes = currentHour * 60 + currentMinute
           const targetTotalMinutes = targetHour * 60 + targetMinute
           
           return targetTotalMinutes > currentTotalMinutes
         }
        
                 // Functions
         function handleStartPause() {
           setIsRunning(!isRunning)
           // Sync game state to Firebase
           syncGameState({
             isRunning: !isRunning,
             players,
             eliminatedIds,
             rebuyCounts,
             currentLevelIndex,
             remainingSeconds,
             gameStarted,
             breakSeconds,
             isOnBreak,
             addonBreakTriggered,
             addonBreakPending,
             spotifyUrl,
             currentTrack
           })
         }
         
         function startGame() {
           // Check if addon time is valid (not in the past)
           if (!isAddonTimeValid()) {
             if (lang === 'he') {
               alert('×©×’×™××”: ×–××Ÿ Addon ×©×”×•×’×“×¨ ×”×•× ×‘×¢×‘×¨. ×× × ×©× ×” ××ª ×–××Ÿ Addon ×œ×©×¢×” ×¢×ª×™×“×™×ª ×œ×¤× ×™ ×”×ª×—×œ×ª ×”××©×—×§.')
             } else {
               alert(t.addonTimePastError)
             }
             return // Prevent game from starting
           }
           
           if (confirm(t.confirmStartGame)) {
             setGameStarted(true)
             setIsRunning(true)
             console.log('ğŸ® Tournament officially started! Settings locked.')
             
             // Sync game state to Firebase
             syncGameState({
               isRunning: true,
               gameStarted: true,
               players,
               eliminatedIds,
               rebuyCounts,
               currentLevelIndex,
               remainingSeconds,
               breakSeconds,
               isOnBreak,
               addonBreakTriggered,
               addonBreakPending,
               spotifyUrl,
               currentTrack
             })
           }
         }
         
         function handleReset() {
           setIsRunning(false)
            // Don't reset level - stay on current level
            // Only reset the timer for the current level
            setRemainingSeconds(getTimePerLevelInSeconds())
           // Don't reset elapsed time - keep tournament running time
           setBreakSeconds(0)
           setIsOnBreak(false)
           // Note: gameStarted remains true - once started, it stays started
           
           // Sync game state to Firebase
           syncGameState({
             isRunning: false,
             gameStarted,
             players,
             eliminatedIds,
             rebuyCounts,
             currentLevelIndex,
             remainingSeconds: getTimePerLevelInSeconds(),
             breakSeconds: 0,
             isOnBreak: false,
             addonBreakTriggered,
             addonBreakPending,
             spotifyUrl,
             currentTrack
           })
         }
         
         function toggleEliminated(id) {
           console.log('ğŸ”„ Toggling elimination for player', id, 'current eliminated:', eliminatedIds)
           
           // Calculate the new eliminated IDs first
           const newEliminatedIds = eliminatedIds.includes(id) 
             ? eliminatedIds.filter(x => x !== id) 
             : [...eliminatedIds, id]
           
           console.log('ğŸ“Š New eliminated IDs:', newEliminatedIds)
           
           // Update local state
           setEliminatedIds(newEliminatedIds)
           
           // Sync game state to Firebase with the NEW eliminated IDs
           syncGameState({
             isRunning,
             gameStarted,
             players,
             eliminatedIds: newEliminatedIds, // Use the calculated new value
             rebuyCounts,
             currentLevelIndex,
             remainingSeconds,
             breakSeconds,
             isOnBreak,
             addonBreakTriggered,
             addonBreakPending,
             spotifyUrl,
             currentTrack
           })
           
           console.log('ğŸ“¤ Elimination sync sent to Firebase:', {
             playerId: id,
             oldEliminatedIds: eliminatedIds,
             newEliminatedIds: newEliminatedIds,
             action: eliminatedIds.includes(id) ? 'uneliminated' : 'eliminated'
           })
         }
         
         function addRebuy(id) {
            const currentRebuys = rebuyCounts[id] || 0
            if (currentRebuys < maxRebuys) {
              console.log('ğŸ”„ Adding rebuy for player', id, 'current:', currentRebuys, 'max:', maxRebuys)
              
              // Calculate new rebuy counts first
              const newRebuyCounts = { ...rebuyCounts, [id]: currentRebuys + 1 }
              console.log('ğŸ“Š New rebuy counts:', newRebuyCounts)
              
              // Update local state
              setRebuyCounts(newRebuyCounts)
              
              // Sync game state to Firebase with the NEW rebuy counts
              syncGameState({
                isRunning,
                gameStarted,
                players,
                eliminatedIds,
                rebuyCounts: newRebuyCounts, // Use the calculated new value
                currentLevelIndex,
                remainingSeconds,
                breakSeconds,
                isOnBreak,
                addonBreakTriggered,
                addonBreakPending,
                spotifyUrl,
                currentTrack
              })
              
              console.log('ğŸ“¤ Rebuy sync sent to Firebase:', {
                playerId: id,
                oldRebuys: currentRebuys,
                newRebuys: newRebuyCounts[id],
                action: 'added'
              })
            } else {
              console.log('ğŸš« Cannot add rebuy - max reached for player', id)
            }
         }
         
         function removeRebuy(id) {
           const currentRebuys = rebuyCounts[id] || 0
           if (currentRebuys > 0) {
             console.log('ğŸ”„ Removing rebuy for player', id, 'current:', currentRebuys)
             
             // Calculate new rebuy counts first
             const newRebuyCounts = { ...rebuyCounts, [id]: Math.max(0, currentRebuys - 1) }
             console.log('ğŸ“Š New rebuy counts:', newRebuyCounts)
             
             // Update local state
             setRebuyCounts(newRebuyCounts)
             
             // Sync game state to Firebase with the NEW rebuy counts
             syncGameState({
               isRunning,
               gameStarted,
               players,
               eliminatedIds,
               rebuyCounts: newRebuyCounts, // Use the calculated new value
               currentLevelIndex,
               remainingSeconds,
               breakSeconds,
               isOnBreak,
               addonBreakTriggered,
               addonBreakPending,
               spotifyUrl,
               currentTrack
             })
             
             console.log('ğŸ“¤ Rebuy sync sent to Firebase:', {
               playerId: id,
               oldRebuys: currentRebuys,
               newRebuys: newRebuyCounts[id],
               action: 'removed'
             })
           } else {
             console.log('ğŸš« Cannot remove rebuy - already at 0 for player', id)
           }
         }
         
         function updatePlayerName(index, name) {
           if (gameStarted) {
             console.log('ğŸš« Cannot change player names after game has started')
             return
           }
           setPlayers(prev => {
             const next = [...prev]
             next[index] = { ...next[index], name }
             
             // Sync game state to Firebase
             syncGameState({
               isRunning,
               gameStarted,
               players: next,
               eliminatedIds,
               rebuyCounts,
               currentLevelIndex,
               remainingSeconds,
               breakSeconds,
               isOnBreak,
               addonBreakTriggered,
               addonBreakPending,
               spotifyUrl,
               currentTrack
             })
             
             return next
           })
         }
         
         function seatRandom() {
           if (gameStarted) {
             console.log('ğŸš« Cannot change seating after game has started')
             return
           }
           
           // Generate the new seating arrangement
           let newPlayers
           if (players.length !== numPlayers) {
                // Create new players array with correct length
             newPlayers = Array.from({ length: numPlayers }, (_, i) => ({ 
                  id: i + 1, 
                  name: t.playerPlaceholder(i + 1)
                }))
              } else {
                // Keep original IDs but shuffle the order
             newPlayers = [...players]
           }
           
           // Shuffle the players
           newPlayers = newPlayers.sort(() => Math.random() - 0.5)
           
           // Update local state
           setPlayers(newPlayers)
            setRebuyCounts({})
            setEliminatedIds([])
           
           // Sync game state to Firebase immediately with the new seating
           setTimeout(() => {
             syncGameState({
               isRunning,
               gameStarted,
               players: newPlayers,
               eliminatedIds: [],
               rebuyCounts: {},
               currentLevelIndex,
               remainingSeconds,
               breakSeconds,
               isOnBreak,
               addonBreakTriggered,
               addonBreakPending,
               spotifyUrl,
               currentTrack
             })
           }, 50)
          }
          
          function resetPlayers() {
            setPlayers(Array.from({ length: numPlayers }, (_, i) => ({ 
              id: i + 1, 
              name: t.playerPlaceholder(i + 1)
            })))
            setRebuyCounts({})
            setEliminatedIds([])
            
            // Sync game state to Firebase
            setTimeout(() => {
              syncGameState({
                isRunning,
                gameStarted,
                players: Array.from({ length: numPlayers }, (_, i) => ({ 
                  id: i + 1, 
                  name: t.playerPlaceholder(i + 1)
                })),
                eliminatedIds: [],
                rebuyCounts: {},
                currentLevelIndex,
                remainingSeconds,
                breakSeconds,
                isOnBreak,
                addonBreakTriggered,
                addonBreakPending,
                spotifyUrl,
                currentTrack
              })
            }, 100)
          }
          
          function newGame() {
            if (confirm(t.confirmNewGame)) {
              // Clear saved game state
        localStorage.removeItem('pokerTournamentState')
        
        // Reset all tournament state
              setIsAppUnlocked(false)
              setShowAppLogin(true)
              setIsRunning(false)
              setGameStarted(false)
              setCurrentLevelIndex(0)
              setRemainingSeconds(600)
              setMinutesPerLevel(10)
              setTimeFormat('minutes')
              setTimePerLevelMMSS('10:00')
              setElapsedSeconds(0)
              setBreakSeconds(0)
              setIsOnBreak(false)
              setAutoBreakMinutes(0)
              setAddonBreakTriggered(false)
              setAddonBreakPending(false)
              setNumPlayers(6)
              setPlayers(Array.from({ length: 6 }, (_, i) => ({ 
                id: i + 1, 
                name: t.playerPlaceholder(i + 1)
              })))
              setEliminatedIds([])
              setRebuyCounts({})
              setLevels([
                { level: 1, smallBlind: 25, bigBlind: 50 },
                { level: 2, smallBlind: 50, bigBlind: 100 },
                { level: 3, smallBlind: 100, bigBlind: 200 },
                { level: 4, smallBlind: 200, bigBlind: 400 },
                { level: 5, smallBlind: 400, bigBlind: 800 },
                { level: 6, smallBlind: 800, bigBlind: 1600 },
                { level: 7, smallBlind: 1600, bigBlind: 3200 },
                { level: 8, smallBlind: 3200, bigBlind: 6400 },
                { level: 9, smallBlind: 6400, bigBlind: 12800 },
                { level: 10, smallBlind: 12800, bigBlind: 25600 },
                { level: 11, smallBlind: 25600, bigBlind: 51200 },
                { level: 12, smallBlind: 51200, bigBlind: 102400 }
              ])
              setMaxRebuys(3)
              setNumWinners(3)
              setAddonTime('')
              setPrizePool(1000)
              setRatioInput('50/30/20')
                      setBuyInPrice(50)
        setRebuyPrice(50)
        setCurrency('USD')
         setLowestChipValue(25)
         setDesiredNumberOfLevels(12)
              setSpotifyUrl('')
              setCurrentTrack(null)
              

            }
         }
         
         // Break timer functions
         function startBreak(minutes) {
           setBreakSeconds(minutes * 60)
           setIsOnBreak(true)
           setIsRunning(false) // Pause the blind timer
           console.log(`ğŸ”„ Break started: ${minutes} minutes`)
           
           // Sync game state to Firebase
           setTimeout(() => {
             syncGameState({
               isRunning: false,
               gameStarted,
               players,
               eliminatedIds,
               rebuyCounts,
               currentLevelIndex,
               remainingSeconds,
               breakSeconds: minutes * 60,
               isOnBreak: true,
               addonBreakTriggered,
               addonBreakPending,
               spotifyUrl,
               currentTrack
             })
           }, 100)
         }
         
         function toggleBreakPause() {
           if (breakSeconds > 0) {
              if (!isOnBreak) {
                // Resuming break - pause the blind timer
                setIsRunning(false)
              }
             setIsOnBreak(!isOnBreak)
             
             // Sync game state to Firebase
             setTimeout(() => {
               syncGameState({
                 isRunning: false,
                 gameStarted,
                 players,
                 eliminatedIds,
                 rebuyCounts,
                 currentLevelIndex,
                 remainingSeconds,
                 breakSeconds,
                 isOnBreak: !isOnBreak,
                 addonBreakTriggered,
                 addonBreakPending,
                 spotifyUrl,
                 currentTrack
               })
             }, 100)
           }
         }
         
         // Sound functions
         function playChime() {
           if (!soundEnabled) return
           
           try {
             // Create a double-beep sound that sounds more like an airport announcement
             const audioContext = new (window.AudioContext || window.webkitAudioContext)()
             
             // First beep (higher pitch)
             const oscillator1 = audioContext.createOscillator()
             const gainNode1 = audioContext.createGain()
             
             oscillator1.connect(gainNode1)
             gainNode1.connect(audioContext.destination)
             
             oscillator1.frequency.setValueAtTime(1000, audioContext.currentTime) // 1000 Hz
             oscillator1.type = 'sine'
             
             gainNode1.gain.setValueAtTime(0.3, audioContext.currentTime)
             gainNode1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3)
             
             oscillator1.start(audioContext.currentTime)
             oscillator1.stop(audioContext.currentTime + 0.3)
             
             // Second beep (lower pitch, delayed)
             const oscillator2 = audioContext.createOscillator()
             const gainNode2 = audioContext.createGain()
             
             oscillator2.connect(gainNode2)
             gainNode2.connect(audioContext.destination)
             
             oscillator2.frequency.setValueAtTime(800, audioContext.currentTime + 0.4) // 800 Hz, delayed
             oscillator2.type = 'sine'
             
             gainNode2.gain.setValueAtTime(0.3, audioContext.currentTime + 0.4)
             gainNode2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.7)
             
             oscillator2.start(audioContext.currentTime + 0.4)
             oscillator2.stop(audioContext.currentTime + 0.7)
             
           } catch (error) {
             console.log('Audio playback failed:', error)
             // Simple fallback alert

           }
         }
         
                   // Fullscreen functions
          function toggleFullscreen() {
            if (!document.fullscreenElement) {
              document.documentElement.requestFullscreen().then(() => {
                setIsFullscreen(true)
              }).catch(err => {
                // Fullscreen error handled silently
              })
            } else {
              document.exitFullscreen().then(() => {
                setIsFullscreen(false)
              }).catch(err => {
                // Fullscreen error handled silently
              })
            }
          }
          
                                      // Function to restore saved game state
         function restoreSavedGameState() {
           // Get the saved state
           const savedState = localStorage.getItem('pokerTournamentState')
           
           if (savedState) {
             try {
               const gameState = JSON.parse(savedState)
               
               // RESTORE ALL IMPORTANT GAME STATE
               if (gameState.players) {
                 setPlayers(gameState.players)
               }
               
               if (gameState.eliminatedIds) {
                 setEliminatedIds(gameState.eliminatedIds)
               }
               
               if (gameState.rebuyCounts) {
                 setRebuyCounts(gameState.rebuyCounts)
               }
               
               if (gameState.currentLevelIndex !== undefined) {
                 setCurrentLevelIndex(gameState.currentLevelIndex)
               }
               
               if (gameState.remainingSeconds !== undefined) {
                 setRemainingSeconds(gameState.remainingSeconds)
               }
               
               // Restore time settings
               if (gameState.timeFormat !== undefined) {
                 setTimeFormat(gameState.timeFormat)
               }
               
               if (gameState.timePerLevelMMSS !== undefined) {
                 setTimePerLevelMMSS(gameState.timePerLevelMMSS)
               }
               
               if (gameState.minutesPerLevel !== undefined) {
                 setMinutesPerLevel(gameState.minutesPerLevel)
               }
               
               if (gameState.autoBreakMinutes !== undefined) {
                 setAutoBreakMinutes(gameState.autoBreakMinutes)
               }
               
               if (gameState.breakSeconds !== undefined) {
                 setBreakSeconds(gameState.breakSeconds)
               }
               
               if (gameState.isOnBreak !== undefined) {
                 setIsOnBreak(gameState.isOnBreak)
               }
               
               if (gameState.elapsedSeconds !== undefined) {
                 setElapsedSeconds(gameState.elapsedSeconds)
               }
               
               if (gameState.addonTime !== undefined) {
                 setAddonTime(gameState.addonTime)
               }
               
               // Restore addon break state
               if (gameState.addonBreakTriggered !== undefined) {
                 setAddonBreakTriggered(gameState.addonBreakTriggered)
               }
               
               if (gameState.addonBreakPending !== undefined) {
                 setAddonBreakPending(gameState.addonBreakPending)
               }
               
               if (gameState.numWinners !== undefined) {
                 setNumWinners(gameState.numWinners)
               }
               
               if (gameState.prizePool !== undefined) {
                 setPrizePool(gameState.prizePool)
               }
               
               if (gameState.ratioInput !== undefined) {
                 setRatioInput(gameState.ratioInput)
               }
               
               // CRITICAL: Restore game state to lock settings
               if (gameState.gameStarted !== undefined) {
                 setGameStarted(gameState.gameStarted)
               }
               
               // ALWAYS PAUSE TIMERS when loading saved game for safety
               // This allows user to review state before resuming
               setIsRunning(false)
               
               // Store the original running state so user knows what it was
               const wasRunning = gameState.isRunning || false
               
               if (gameState.numPlayers !== undefined) {
                 setNumPlayers(gameState.numPlayers)
               }
               
               if (gameState.levels) {
                 setLevels(gameState.levels)
               }
               
               if (gameState.maxRebuys !== undefined) {
                 setMaxRebuys(gameState.maxRebuys)
             }
               
               if (gameState.buyInPrice !== undefined) {
                 setBuyInPrice(gameState.buyInPrice)
               }
               
               if (gameState.rebuyPrice !== undefined) {
                 setRebuyPrice(gameState.rebuyPrice)
               }

                                if (gameState.lowestChipValue !== undefined) {
                   setLowestChipValue(gameState.lowestChipValue)
                 }

                 if (gameState.desiredNumberOfLevels !== undefined) {
                   setDesiredNumberOfLevels(gameState.desiredNumberOfLevels)
                 }
                 
                 if (gameState.userDefaultLevels !== undefined) {
                   setUserDefaultLevels(gameState.userDefaultLevels)
                 }
               
             } catch (error) {
                                console.error('Error restoring game state:', error)
             }
            }
          }
          
                   // App access functions
         function handleAppUnlock() {
           if (appPassword === '1234') {
             if (selectedAction === 'new') {
               // For new game, clear saved state and start fresh
               localStorage.removeItem('pokerTournamentState')
             } else if (selectedAction === 'load') {
               // For loading saved game, restore the saved state
               restoreSavedGameState()
             }
             
             // Unlock the app
             setIsAppUnlocked(true)
             setShowAppLogin(false)
             setAppPassword('')
             setSelectedAction(null)
           } else {
             alert(t.incorrectPassword)
             setAppPassword('')
           }
         }
         
         // Admin functions
         function handleAdminAccess() {
           if (adminPassword === '1234') {
             // Set the admin mode based on what was requested
             if (requestedAdminMode) {
               setIsAdminMode(requestedAdminMode)
               setRequestedAdminMode(null)
             }
             setShowAdminLogin(false)
             setAdminPassword('')
           } else {
             alert(t.incorrectPassword)
             setAdminPassword('')
           }
         }
         
         function exitAdmin() {
           setIsAdminMode(false)
           setShowAdminLogin(false)
           setAdminPassword('')
           setRequestedAdminMode(null)
         }
         
         // Function to manually reset addon break state
         function resetAddonBreak() {
           setAddonBreakTriggered(false)
           setAddonBreakPending(false)
           console.log('ğŸ”„ Addon break state reset')
         }
         
         function addBlindLevel() {
           const newLevel = levels.length + 1
           const lastLevel = levels[levels.length - 1]
           const smallBlind = lastLevel ? lastLevel.smallBlind * 2 : lowestChipValue
           const bigBlind = lastLevel ? lastLevel.bigBlind * 2 : lowestChipValue * 2
           
           setLevels([...levels, { level: newLevel, smallBlind, bigBlind }])
         }

         function generateBlindLevels() {
           if (lowestChipValue <= 0) {
             alert(t.chipValueMustBeGreaterThanZero)
             return
           }

           if (desiredNumberOfLevels <= 0) {
             alert(t.numberOfLevelsMustBeGreaterThanZero)
             return
           }

           const newLevels = []
           let smallBlind = lowestChipValue
           let bigBlind = lowestChipValue * 2

           // Generate desired number of levels with progressive doubling
           for (let i = 1; i <= desiredNumberOfLevels; i++) {
             newLevels.push({
               level: i,
               smallBlind: smallBlind,
               bigBlind: bigBlind
             })
             
             // Double the blinds for next level
             smallBlind *= 2
             bigBlind *= 2
           }

           setLevels(newLevels)
         }

         function updateBlindLevelsForNewChipValue() {
           if (levels.length === 0) return
           
           const newLevels = []
           let smallBlind = lowestChipValue
           let bigBlind = lowestChipValue * 2

           // Update existing levels with new progression, maintaining current count
           const currentLevelCount = levels.length
           for (let i = 0; i < currentLevelCount; i++) {
             newLevels.push({
               level: i + 1,
               smallBlind: smallBlind,
               bigBlind: bigBlind
             })
             
             // Double the blinds for next level
             smallBlind *= 2
             bigBlind *= 2
           }

           setLevels(newLevels)
         }
         
         function removeBlindLevel() {
           if (levels.length > 1) {
             setLevels(levels.slice(0, -1))
           }
         }
         
         function resetToDefaults() {
           // Clear any old localStorage data that might have old defaults
           localStorage.removeItem('pokerTournamentState')
           
           // Reset to default values
           setLowestChipValue(25)
           setDesiredNumberOfLevels(12)
           
           // Generate default levels based on new defaults
           const defaultLevels = []
           let smallBlind = 25
           let bigBlind = 50

           for (let i = 1; i <= 12; i++) {
             defaultLevels.push({
               level: i,
               smallBlind: smallBlind,
               bigBlind: bigBlind
             })
             
             // Double the blinds for next level
             smallBlind *= 2
             bigBlind *= 2
           }

           setLevels(defaultLevels)
           setTimeFormat('minutes')
           setTimePerLevelMMSS('10:00')
         }
         
         // User default blind level functions
         function saveUserDefaultLevels() {
           const userDefaults = {
             levels: [...levels],
             lowestChipValue,
             desiredNumberOfLevels,
             savedAt: Date.now()
           }
           
           localStorage.setItem('userDefaultBlindLevels', JSON.stringify(userDefaults))
           setUserDefaultLevels(userDefaults)
           
           // Show success message
           alert(t.blindLevelListSavedAsPersonalDefault)
         }
         
         function restoreUserDefaultLevels() {
           if (userDefaultLevels) {
             setLevels([...userDefaultLevels.levels])
             setLowestChipValue(userDefaultLevels.lowestChipValue)
             setDesiredNumberOfLevels(userDefaultLevels.desiredNumberOfLevels)
             
             // Show success message
           alert(t.personalBlindLevelListRestored)
           } else {
             // Show error message
               alert(t.noPersonalDefaultsFound)
           }
         }
         
         function clearUserDefaultLevels() {
           localStorage.removeItem('userDefaultBlindLevels')
           setUserDefaultLevels(null)
           
           // Show success message
           alert(t.personalDefaultsCleared)
         }
         
         // Prize calculator functions
          function parseRatio(ratioStr, winners) {
           const parts = ratioStr.split('/').map(Number)
            if (parts.length !== winners || parts.some(isNaN)) {
              // Generate default ratios based on number of winners
              const defaultRatios = []
              for (let i = 0; i < winners; i++) {
                if (i === 0) defaultRatios.push(50) // 1st place gets 50%
                else if (i === 1) defaultRatios.push(30) // 2nd place gets 30%
                else if (i === 2) defaultRatios.push(20) // 3rd place gets 20%
                else defaultRatios.push(Math.max(5, 20 - (i * 5))) // Subsequent places get decreasing amounts
              }
              return defaultRatios
            }
           return parts
         }
         
         // Spotify functions
         function handleSpotifyPlay() {
           if (!spotifyUrl.trim()) return
           
           // Extract track/playlist ID from Spotify URL
           const match = spotifyUrl.match(/spotify\.com\/(track|playlist|album)\/([a-zA-Z0-9]+)/)
           if (match) {
             const [, type, id] = match
             setCurrentTrack({ type, id, url: spotifyUrl })
             
             // Sync game state to Firebase
             syncGameState({
               isRunning,
               gameStarted,
               players,
               eliminatedIds,
               rebuyCounts,
               currentLevelIndex,
               remainingSeconds,
               breakSeconds,
               isOnBreak,
               addonBreakTriggered,
               addonBreakPending,
               spotifyUrl,
               currentTrack: { type, id, url: spotifyUrl }
             })
           } else {
             alert(t.pleaseEnterValidSpotifyUrl)
           }
         }
         
         function extractSpotifyEmbedUrl(url) {
           const match = url.match(/spotify\.com\/(track|playlist|album)\/([a-zA-Z0-9]+)/)
           if (match) {
             const [, type, id] = match
             return `https://open.spotify.com/embed/${type}/${id}`
           }
           return null
         }
         
         // Calculate total prize pool automatically
         const totalPrizePool = useMemo(() => {
           const buyInTotal = buyInPrice * numPlayers
           const rebuyTotal = Object.values(rebuyCounts).reduce((sum, count) => sum + (count * rebuyPrice), 0)
           return buyInTotal + rebuyTotal
         }, [buyInPrice, rebuyPrice, numPlayers, rebuyCounts])
         
         const prizeDistribution = useMemo(() => {
            const ratio = parseRatio(ratioInput, numWinners)
           const total = ratio.reduce((sum, r) => sum + r, 0)
           return ratio.map(r => Math.round((r / total) * totalPrizePool))
          }, [ratioInput, totalPrizePool, numWinners])
         
                   // Seat positions are now calculated directly in the JSX for simplicity
        
                 // Auto-update blind levels when lowest chip value changes
         // useEffect(() => {
         //   if (levels.length > 0 && lowestChipValue > 0) {
         //     updateBlindLevelsForNewChipValue()
         //   }
         // }, [lowestChipValue])

         // Auto-update blind levels when desired number of levels changes
         // useEffect(() => {
         //   if (levels.length > 0 && desiredNumberOfLevels > 0 && levels.length !== desiredNumberOfLevels) {
         //     generateBlindLevels()
         //   }
         // }, [desiredNumberOfLevels])
        
                 // Timer effects
         useEffect(() => {
           if (!isRunning) return
           
           intervalRef.current = setInterval(() => {
             setRemainingSeconds(prev => {
               const newRemainingSeconds = (() => {
               if (prev <= 1) {
                 // Check if addon break is pending before level progression
                 if (addonBreakPending && !isOnBreak && gameStarted) {
                   console.log('ğŸ Level ended, starting addon break...')
                   console.log('ğŸ“Š Debug - addonBreakPending:', addonBreakPending, 'isOnBreak:', isOnBreak, 'gameStarted:', gameStarted)
                   
                   // Start 15-minute break immediately
                   startBreak(15)
                   setAddonBreakPending(false)
                   
                   // Show notification that break is starting now (only if not in game)
                   if (!isRunning && !isOnBreak) {
                       alert(t.addonBreakStartingNow)
                   }
                   
                   // Don't progress level yet - wait for break to end
                   return 0
                 } else {
                   console.log('ğŸ” Debug - Level ending check:', {
                     addonBreakPending,
                     isOnBreak,
                     gameStarted,
                     remainingSeconds: prev
                   })
                 }
                 
                 // Level up (only if no addon break is pending)
                 if (currentLevelIndex < levels.length - 1) {
                   setCurrentLevelIndex(prev => {
                     const newLevelIndex = prev + 1
                     
                     // Sync game state to Firebase when level changes
                     setTimeout(() => {
                       syncGameState({
                         isRunning,
                         gameStarted,
                         players,
                         eliminatedIds,
                         rebuyCounts,
                         currentLevelIndex: newLevelIndex,
                         remainingSeconds: getTimePerLevelInSeconds(),
                         breakSeconds,
                         isOnBreak,
                         addonBreakTriggered,
                         addonBreakPending,
                         spotifyUrl,
                         currentTrack
                       })
                     }, 100)
                     
                     return newLevelIndex
                   })
                   playChime()
                   return getTimePerLevelInSeconds()
                 } else {
                   // Reached last level - show infinity but keep counting total time
                   // Only play chime once when reaching the last level, not continuously
                   if (prev > 0) {
                   playChime()
                   }
                   return 0
                 }
               }
               return prev - 1
               })()
               
               // Sync game state to Firebase every 10 seconds to avoid too many updates
               if (newRemainingSeconds % 10 === 0) {
                 syncGameState({
                   isRunning,
                   gameStarted,
                   players,
                   eliminatedIds,
                   rebuyCounts,
                   currentLevelIndex,
                   remainingSeconds: newRemainingSeconds,
                   breakSeconds,
                   isOnBreak,
                   addonBreakTriggered,
                   addonBreakPending,
                   spotifyUrl,
                   currentTrack
                 })
               }
               
               return newRemainingSeconds
             })
           }, 1000)
           
           return () => clearInterval(intervalRef.current)
         }, [isRunning, currentLevelIndex, levels.length, timeFormat, minutesPerLevel, timePerLevelMMSS, addonBreakPending, isOnBreak, gameStarted, lang])
         
         // Break timer effect
         useEffect(() => {
           if (!isOnBreak || breakSeconds <= 0) return
           
           breakIntervalRef.current = setInterval(() => {
             setBreakSeconds(prev => {
               const newBreakSeconds = prev <= 1 ? 0 : prev - 1
               
               // Sync game state to Firebase when break ends
               if (newBreakSeconds === 0 && prev > 0) {
                 setIsOnBreak(false)
                 playChime()
                 
                 setTimeout(() => {
                   syncGameState({
                     isRunning,
                     gameStarted,
                     players,
                     eliminatedIds,
                     rebuyCounts,
                     currentLevelIndex,
                     remainingSeconds,
                     breakSeconds: 0,
                     isOnBreak: false,
                     addonBreakTriggered,
                     addonBreakPending,
                     spotifyUrl,
                     currentTrack
                   })
                 }, 100)
               }
               
               return newBreakSeconds
             })
           }, 1000)
           
           return () => clearInterval(breakIntervalRef.current)
          }, [isOnBreak, breakSeconds, soundEnabled])
         
                   // Elapsed time effect - count game time, continue even after last level
         useEffect(() => {
            if (!isRunning) return
           
           elapsedIntervalRef.current = setInterval(() => {
             setElapsedSeconds(prev => prev + 1)
           }, 1000)
           
           return () => clearInterval(elapsedIntervalRef.current)
          }, [isRunning])
         
         // Addon break system - triggers 15-minute break when addon time is reached
         useEffect(() => {
           if (!addonTime || !gameStarted) return // Only work when game is started
           
           const checkInterval = setInterval(() => {
             const now = new Date()
             const currentHour = now.getHours()
             const currentMinute = now.getMinutes()
             const [targetHour, targetMinute] = addonTime.split(':').map(Number)
             
             if (currentHour === targetHour && currentMinute === targetMinute && !addonBreakTriggered) {
               console.log('ğŸ• Addon time reached! Marking break as pending...')
               console.log('ğŸ“Š Debug - Setting addonBreakPending to true, addonBreakTriggered to true')
               
               // Addon time reached - mark as pending break (don't start immediately)
               setAddonBreakPending(true)
               setAddonBreakTriggered(true) // Prevent multiple triggers
               playChime() // Play sound to notify
               
               // Sync game state to Firebase
               setTimeout(() => {
                 syncGameState({
                   isRunning,
                   gameStarted,
                   players,
                   eliminatedIds,
                   rebuyCounts,
                   currentLevelIndex,
                   remainingSeconds,
                   breakSeconds,
                   isOnBreak,
                   addonBreakTriggered: true,
                   addonBreakPending: true,
                   spotifyUrl,
                   currentTrack
                 })
               }, 100)
               
               // Force a re-render to ensure state is updated
               setTimeout(() => {
                 console.log('ğŸ”„ State update check - addonBreakPending should be true:', addonBreakPending)
               }, 100)
               
               // Show notification that break will start at end of current level (only if not in game)
               if (!isRunning && !isOnBreak) {
                     alert(t.addonTimeReached)
               }
             }
           }, 1000)
           
           return () => clearInterval(checkInterval)
          }, [addonTime, lang, addonBreakTriggered, gameStarted])
          

          
          // Addon timer display update effect - updates every second for smooth countdown
          useEffect(() => {
            if (!addonTime) return
            
            const displayInterval = setInterval(() => {
              // Force re-render to update the addon timer display
              setAddonSeconds(prev => prev + 1)
            }, 1000)
            
            return () => clearInterval(displayInterval)
          }, [addonTime])
         
                   // Save game state to localStorage whenever important state changes
          useEffect(() => {
            // Don't auto-save when on the start screen (app not unlocked)
            if (!isAppUnlocked) {
              console.log('ğŸ” Auto-save skipped - app not unlocked')
              return
            }
            
            console.log('ğŸ” Auto-save effect running with numPlayers:', numPlayers)
            console.log('ğŸ” Current localStorage before auto-save:', localStorage.getItem('pokerTournamentState'))
            
            const gameState = {
              isRunning,
              gameStarted,
              currentLevelIndex,
              remainingSeconds,
              minutesPerLevel,
              timeFormat,
              timePerLevelMMSS,
              elapsedSeconds,
              breakSeconds,
              isOnBreak,
              addonBreakTriggered,
              addonBreakPending,
              autoBreakMinutes,
              numPlayers,
              players,
              eliminatedIds,
              rebuyCounts,
              levels,
              maxRebuys,
              addonTime,
              numWinners,
              prizePool,
              ratioInput,
              buyInPrice,
              rebuyPrice,
              currency,
           lowestChipValue,
           desiredNumberOfLevels,
           userDefaultLevels,
              spotifyUrl,
              currentTrack,
              savedAt: Date.now() // Add timestamp for tracking
            }
            
            localStorage.setItem('pokerTournamentState', JSON.stringify(gameState))
          }, [
            isAppUnlocked, isRunning, gameStarted, currentLevelIndex, remainingSeconds, minutesPerLevel,
            timeFormat, timePerLevelMMSS, elapsedSeconds, breakSeconds, isOnBreak, addonBreakTriggered, addonBreakPending, autoBreakMinutes,
            numPlayers, players, eliminatedIds, rebuyCounts, levels,
            maxRebuys, addonTime, numWinners, prizePool, ratioInput, buyInPrice, rebuyPrice, currency, lowestChipValue, desiredNumberOfLevels, userDefaultLevels, spotifyUrl, currentTrack
          ])
          
          // Player count effect - handle dynamic player count changes
          useEffect(() => {
            const savedState = localStorage.getItem('pokerTournamentState')
            if (!savedState) {
              // Only create default players if no saved state exists
           setPlayers(Array.from({ length: numPlayers }, (_, i) => ({ 
             id: i + 1, 
             name: t.playerPlaceholder(i + 1)
           })))
              setRebuyCounts({})
              setEliminatedIds([])
            } else {
              // If we have saved state but numPlayers changed, update players array
              setPlayers(prevPlayers => {
                if (prevPlayers.length !== numPlayers) {
                  // Create new players array with correct length
                  const newPlayers = Array.from({ length: numPlayers }, (_, i) => {
                    // Try to preserve existing player data if possible
                    if (i < prevPlayers.length) {
                      return prevPlayers[i]
                    } else {
                      // Create new player for additional seats
                      return { 
                        id: i + 1, 
                        name: t.playerPlaceholder(i + 1)
                      }
                    }
                  })
                  return newPlayers
                }
                return prevPlayers
              })
              // DON'T reset rebuy counts and eliminated status when player count changes
              // This preserves the saved state
            }
         }, [numPlayers, t.playerPlaceholder])
         
         // Language effect
         useEffect(() => {
           document.documentElement.lang = lang
           document.documentElement.dir = lang === 'he' ? 'rtl' : 'ltr'
            
            // Only update player names when language changes if no saved game exists
            // This prevents overwriting saved player names
            const savedState = localStorage.getItem('pokerTournamentState')
            if (!savedState) {
            setPlayers(prev => prev.map((player, idx) => ({
              ...player,
              name: t.playerPlaceholder(idx + 1)
            })))
            }
          }, [lang, t.playerPlaceholder])
          
          // Fullscreen change effect
          useEffect(() => {
            const handleFullscreenChange = () => {
              setIsFullscreen(!!document.fullscreenElement)
            }
            
            document.addEventListener('fullscreenchange', handleFullscreenChange)
            return () => document.removeEventListener('fullscreenchange', handleFullscreenChange)
          }, [])
        
                 // Format time
         function formatTime(seconds) {
           const mins = Math.floor(seconds / 60)
           const secs = seconds % 60
           return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
         }
         
         function formatElapsedTime(seconds) {
           const hours = Math.floor(seconds / 3600)
           const mins = Math.floor((seconds % 3600) / 60)
           const secs = seconds % 60
           return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
          }
          
                     function formatTimeUntilAddon() {
             if (!addonTime) return null
             
             const now = new Date()
             const currentHour = now.getHours()
             const currentMinute = now.getMinutes()
             const currentSecond = now.getSeconds()
             
             const [targetHour, targetMinute] = addonTime.split(':').map(Number)
             
             // Calculate total minutes until target time
             let totalMinutesUntilAddon = (targetHour * 60 + targetMinute) - (currentHour * 60 + currentMinute)
             
             // If we've passed the time today, don't add 24 hours - just show 00:00
             if (totalMinutesUntilAddon <= 0) {
               return '00:00'
             }
             
             const totalSecondsUntilAddon = (totalMinutesUntilAddon * 60) - currentSecond
             
             if (totalSecondsUntilAddon <= 0) return '00:00'
             
             const hours = Math.floor(totalSecondsUntilAddon / 3600)
             const mins = Math.floor((totalSecondsUntilAddon % 3600) / 60)
             const secs = totalSecondsUntilAddon % 60
             
             if (hours > 0) {
               return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
             } else {
               return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
             }
         }
        
        return (
          <div className="max-w-7xl mx-auto p-6">
            {/* Room Info Header */}
            <div className="bg-slate-800 border border-slate-700 rounded-lg p-4 mb-6">
              <div className="flex justify-between items-center">
                <div className="flex items-center space-x-4">
                  <div className="bg-green-600 px-3 py-2 rounded-lg text-sm">
                    <span data-room-id>Room: {roomId}</span>
                  </div>
                  <div id="connectionStatus" className="bg-green-600 px-3 py-2 rounded-lg text-sm">
                    <span>Connected</span>
                  </div>
                  {isHost && (
                    <div className="bg-amber-600 px-3 py-2 rounded-lg text-sm">
                      <span>ğŸ‘‘ Host</span>
                    </div>
                  )}
                </div>
                <div className="text-slate-400 text-sm">
                  {lang === 'he' ? '×©×ª×£ ×§×•×“ ×—×“×¨ ×–×” ×¢× ×©×—×§× ×™× ××—×¨×™× ×›×“×™ ×œ×”×¦×˜×¨×£ ×œ××•×ª×• ××©×—×§' : 'Share this room code with other players to join the same game'}
                </div>
              </div>
              
              {/* Room Join Section */}
              <div className="mt-4 pt-4 border-t border-slate-700">
                <div className="flex items-center space-x-4">
                  <div className="text-slate-300 text-sm">{t.joinDifferentRoom}</div>
                  <input
                    type="text"
                    placeholder={t.enterRoomCode}
                    className="bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    value={joinRoomCode}
                    onChange={(e) => setJoinRoomCode(e.target.value.toUpperCase())}
                    maxLength={6}
                  />
                  <button
                    onClick={joinRoom}
                    className="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-white transition-colors"
                  >
                    {t.joinRoom}
                  </button>
                </div>
                <div className="text-slate-400 text-xs mt-2">
                  {t.roomCodeHelper}
                </div>
              </div>
            </div>
            
             {/* App Password Modal */}
             {showAppLogin && (
               <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
                 <div className="bg-slate-800 border border-slate-700 rounded-2xl p-6 w-[500px] max-w-[95vw]">
                   {/* Welcome Message */}
                   <h2 className="text-2xl font-bold text-slate-100 mb-6 text-center">ğŸ® {t.welcomeMessage}</h2>
                   
                   {/* Language Selection */}
                   <div className="mb-6">
                     <label className="text-slate-300 text-sm block mb-3 font-medium">{t.chooseLanguage}:</label>
                     <div className="flex gap-3">
                 <button
                         className={`flex-1 px-4 py-3 rounded-lg border-2 font-medium transition-all ${
                           lang === 'en' 
                             ? 'bg-indigo-600 border-indigo-500 text-white' 
                             : 'bg-slate-700/60 border-slate-600 text-slate-300 hover:bg-slate-700/60'
                         }`}
                         onClick={() => setLang('en')}
                       >
                         ğŸ‡ºğŸ‡¸ English
                       </button>
                       <button
                         className={`flex-1 px-4 py-3 rounded-lg border-2 font-medium transition-all ${
                           lang === 'he' 
                             ? 'bg-indigo-600 border-indigo-500 text-white' 
                             : 'bg-slate-700/60 border-slate-600 text-slate-300 hover:bg-slate-700/60'
                         }`}
                         onClick={() => setLang('he')}
                       >
                         ğŸ‡®ğŸ‡± ×¢×‘×¨×™×ª
                       </button>
                     </div>
                   </div>
                   
                                                             {/* Game Choice Buttons */}
                     <div className="mb-6">
                       <label className="text-slate-300 text-sm block mb-3 font-medium">{t.continueLastGame}:</label>
                     <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
                         {/* Open Recent Game Button */}
                         <button
                           className={`px-4 py-3 rounded-lg border-2 font-medium transition-all ${
                             (() => {
                               const savedState = localStorage.getItem('pokerTournamentState')
                               return savedState ? 'bg-emerald-600 border-emerald-500 text-white hover:bg-emerald-500' : 'bg-slate-500 border-slate-400 text-slate-300 cursor-not-allowed'
                             })()
                   }`}
                   onClick={() => {
                             console.log('ğŸ” Open Recent Game clicked')
                             
                             // Read the saved state ONCE and store it
                             const savedState = localStorage.getItem('pokerTournamentState')
                             console.log('ğŸ” Raw saved state from localStorage:', savedState)
                             
                             if (savedState) {
                               try {
                                 const gameState = JSON.parse(savedState)
                                 console.log('ğŸ” Parsed game state:', gameState)
                               console.log('ğŸ” Players:', gameState.numPlayers || 0)
                                 console.log('ğŸ” Level:', gameState.currentLevelIndex + 1 || 1)
                                 
                                 // Set action to load saved game and show password input
                                 setSelectedAction('load')
                                 console.log('ğŸ” Action set to: load - password input should now be visible')
                                 
                                 // Show info about the saved game (but don't block with alert)
                                 const savedDate = new Date(gameState.savedAt || Date.now())
                                 const dateStr = savedDate.toLocaleDateString(lang === 'he' ? 'he-IL' : 'en-US')
                                 const timeStr = savedDate.toLocaleTimeString(lang === 'he' ? 'he-IL' : 'en-US', { 
                                   hour: '2-digit', 
                                   minute: '2-digit' 
                                 })
                                 
                                 console.log('ğŸ” Ready to load:', `${gameState.numPlayers || 0} players, level ${gameState.currentLevelIndex + 1 || 1}`)
                                 
                               } catch (e) {
                                 console.error('âŒ Error parsing saved state:', e)
                               alert(t.errorReadingSavedGame)
                               }
                     } else {
                               console.log('âŒ No saved state found')
                               alert(t.noSavedGame)
                             }
                           }}
                           disabled={!localStorage.getItem('pokerTournamentState')}
                         >
                           ğŸ’¾ {t.openRecentGame}
                         </button>
                         
                         {/* Start New Game Button */}
                         <button
                           className="px-4 py-3 rounded-lg border-2 font-medium transition-all bg-blue-600 border-blue-500 text-white hover:bg-blue-500"
                           onClick={() => {
                             if (confirm(t.confirmNewGame)) {
                               // Set action to start new game
                               setSelectedAction('new')
                               // Clear saved game state completely
                             localStorage.removeItem('pokerTournamentState')
                               
                               // Show success message
                                                            alert(t.newGameReady)
  
                             }
                           }}
                         >
                           ğŸƒ {t.newGame}
                         </button>
                         
                         {/* Join Different Room Button */}
                         <button
                           className="px-4 py-3 rounded-lg border-2 font-medium transition-all bg-purple-600 border-purple-500 text-white hover:bg-purple-500"
                           onClick={() => {
                             // Set action to join room
                             setSelectedAction('join')
                           }}
                         >
                           ğŸšª {t.joinDifferentRoom}
                         </button>
                       </div>
                       
                       {/* Saved Game Info Display */}
                       {(() => {
                         const savedState = localStorage.getItem('pokerTournamentState')
                         if (savedState) {
                           try {
                             const gameState = JSON.parse(savedState)
                             const savedDate = new Date(gameState.savedAt || Date.now())
                             const dateStr = savedDate.toLocaleDateString(lang === 'he' ? 'he-IL' : 'en-US')
                             const timeStr = savedDate.toLocaleTimeString(lang === 'he' ? 'he-IL' : 'en-US', { 
                               hour: '2-digit', 
                               minute: '2-digit' 
                             })
                             return (
                               <div className="bg-slate-700/40 border border-slate-600 rounded-lg p-4 mt-3">
                                 <div className="text-slate-200 text-sm mb-2">
                                   âœ… {t.savedGameInfo} {dateStr} {timeStr}
                                 </div>
                                 <div className="text-slate-300 text-xs">
                                   {gameState.numPlayers || 0} {t.savedGameDetails} {gameState.currentLevelIndex + 1 || 1}
                                 </div>

                               </div>
                             )
                           } catch (e) {
                             return (
                               <div className="text-slate-400 text-sm italic">
                                 {t.noSavedGame}
                               </div>
                             )
                           }
                         } else {
                           return (
                             <div className="text-slate-400 text-sm italic">
                               {t.noSavedGame}
                             </div>
                           )
                         }
                       })()}
                     </div>
                     
                     {/* Room Joining Section - Only show when join action is selected */}
                     {selectedAction === 'join' && (
                       <div className="space-y-4">
                         <div>
                           <label className="text-slate-300 text-sm block mb-2">
                             {t.enterRoomCode}
                           </label>
                           <input
                             className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-4 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                             type="text"
                             value={joinRoomCode}
                             onChange={(e) => setJoinRoomCode(e.target.value.toUpperCase())}
                             placeholder={t.enterRoomCode}
                             onKeyPress={(e) => e.key === 'Enter' && handleJoinRoomFromStart()}
                             maxLength={6}
                             autoFocus
                           />
                           <div className="text-slate-400 text-xs mt-2">
                             {t.roomCodeHelper}
                           </div>
                         </div>
                         
                         {/* Join Room Action Buttons */}
                         <div className="flex gap-3">
                           <button
                             className="flex-1 px-4 py-3 rounded-lg bg-purple-600 hover:bg-purple-500 text-white font-medium transition-colors"
                             onClick={handleJoinRoomFromStart}
                           >
                             ğŸšª {t.joinRoom}
                           </button>
                           <button
                             className="px-6 py-3 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-100 font-medium transition-colors"
                             onClick={() => setSelectedAction(null)}
                           >
                             â†©ï¸ {t.cancel}
                           </button>
                         </div>
                       </div>
                     )}
                     
                     {/* Password Section - Only show when action is selected */}
                     {selectedAction && selectedAction !== 'join' && (
                     <div className="space-y-4">

                       <div>
                           <label className="text-slate-300 text-sm block mb-2">
                             {selectedAction === 'new' 
                               ? t.enterPasswordForNewGame
                               : t.enterPasswordForSavedGame
                             }
                           </label>
                       <input
                         className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-4 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                         type="password"
                         value={appPassword}
                         onChange={(e) => setAppPassword(e.target.value)}
                                                    placeholder={t.enterPassword}
                           onKeyPress={(e) => e.key === 'Enter' && handleAppUnlock()}
                           autoFocus
                       />
                     </div>
                     {/* Action Buttons */}
                     <div className="flex gap-3">
                       <button
                         className="flex-1 px-4 py-3 rounded-lg bg-indigo-600 hover:bg-indigo-500 text-white font-medium transition-colors"
                         onClick={handleAppUnlock}
                       >
                         ğŸ”“ {t.unlock}
                       </button>
                       <button
                         className="px-6 py-3 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-100 font-medium transition-colors"
                         onClick={() => {
                               setSelectedAction(null)
                           setAppPassword('')
                         }}
                       >
                         âŒ {t.cancel}
                       </button>
                     </div>
                   </div>
                     )}
                 </div>
               </div>
             )}
             
             {/* Audio placeholder - using Web Audio API instead */}
             <div ref={audioRef} style={{display: 'none'}}></div>
             
             {/* App Content - Only show when unlocked */}
             {isAppUnlocked && (
               <>
                                {/* Instructions Banner */}
               <div className="bg-gradient-to-r from-blue-600/20 to-indigo-600/20 border border-blue-500/30 rounded-xl p-4 mb-6">


                 <div className="flex items-center gap-3 mb-2">
                   <span className="text-2xl">ğŸ“š</span>
                   <h3 className="text-blue-200 font-semibold text-lg">{t.howToUse}</h3>
                 </div>
                 <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-blue-100 text-sm">
                   <div>
                     <div className="font-medium mb-1">ğŸ† {t.tournamentTab}:</div>
                     <div className="text-blue-200">{t.tournamentTabDesc1}</div>
                     <div className="text-blue-200">{t.tournamentTabDesc2}</div>
                     <div className="text-blue-200">{t.tournamentTabDesc3}</div>
                     <div className="text-blue-200">â€¢ {lang === 'he' 
                       ? '×”×©×ª××© ×‘×›×¤×ª×•×¨ "×”×ª×—×œ ××©×—×§" ×›×“×™ ×œ× ×¢×•×œ ×”×’×“×¨×•×ª ×”×˜×•×¨× ×™×¨'
                       : 'Use "Start Game" button to lock tournament settings'
                     }</div>
                   </div>
                   <div>
                     <div className="font-medium mb-1">ğŸ’° {t.prizeCalculator}:</div>
                     <div className="text-blue-200">{t.prizeCalculatorDesc1}</div>
                     <div className="text-blue-200">{t.prizeCalculatorDesc2}</div>
                     <div className="text-blue-200">{t.prizeCalculatorDesc3}</div>
                   </div>
                   <div>
                     <div className="font-medium mb-1">âš™ï¸ {t.adminSettings}:</div>
                     <div className="text-blue-200">{t.adminSettingsDesc1}</div>
                     <div className="text-blue-200">{t.adminSettingsDesc2}</div>
                     <div className="text-blue-200">{t.adminSettingsDesc3}</div>
                   </div>
                   <div>
                     <div className="font-medium mb-1">ğŸ® {t.newGame}:</div>
                     <div className="text-blue-200">{t.newGameDesc1}</div>
                     <div className="text-blue-200">{t.newGameDesc2}</div>
                     <div className="text-blue-200">{t.newGameDesc3}</div>
                   </div>
                 </div>
               </div>
             
                          {/* Header */}
             <div className="flex items-center justify-between mb-6">
               <h1 className="text-3xl font-bold text-slate-100">{t.title}</h1>
               <div className="flex items-center gap-3">
                                                     <button
                    className="px-4 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-500 text-white font-medium transition-colors"
                    onClick={newGame}
                  >
                    ğŸƒ {t.newGame}
                  </button>
                  <button
                    className="px-4 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-100 font-medium transition-colors"
                    onClick={toggleFullscreen}
                  >
                    {isFullscreen ? `â›¶ ${t.exitFullscreen}` : `â›¶ ${t.fullscreen}`}
                 </button>
                 <button
                   className="px-4 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-100 font-medium transition-colors"
                   onClick={() => setLang(lang === 'he' ? 'en' : 'he')}
                 >
                   {lang === 'he' ? 'English' : '×¢×‘×¨×™×ª'}
                 </button>
               </div>
                          </div>

             {/* Admin Password Modal */}
             {showAdminLogin && (
               <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
                 <div className="bg-slate-800 border border-slate-700 rounded-2xl p-6 w-96">
                   <h3 className="text-xl font-semibold text-slate-100 mb-4 text-center">ğŸ” {t.adminAccess}</h3>
                   <div className="space-y-4">
                     <div>
                       <label className="text-slate-300 text-sm block mb-2">{t.password}</label>
                       <input
                         className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-4 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                         type="password"
                         value={adminPassword}
                         onChange={(e) => setAdminPassword(e.target.value)}
                         placeholder={t.enterPasswordPlaceholder}
                         onKeyPress={(e) => e.key === 'Enter' && handleAdminAccess()}
                       />
                     </div>
                     <div className="flex gap-3">
                       <button
                         className="flex-1 px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-500 text-white font-medium transition-colors"
                         onClick={handleAdminAccess}
                       >
                         {t.login}
                       </button>
                       <button
                         className="flex-1 px-4 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-100 font-medium transition-colors"
                         onClick={() => {
                           setShowAdminLogin(false)
                           setAdminPassword('')
                           setRequestedAdminMode(null)
                         }}
                       >
                         {t.cancel}
                       </button>
                     </div>
                   </div>
                 </div>
               </div>
             )}

             {/* Tab Navigation */}
             <div className="flex items-center gap-2 mb-6">
               <button
                 className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                   isAdminMode === false 
                     ? 'bg-indigo-600 text-white' 
                     : 'bg-slate-700 hover:bg-slate-600 text-slate-100'
                 }`}
                 onClick={() => setIsAdminMode(false)}
               >
                 ğŸ† {t.tournamentTitle}
               </button>
                                <button
                   className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                    isAdminMode === 'prize' 
                       ? 'bg-indigo-600 text-white' 
                       : 'bg-slate-700 hover:bg-slate-600 text-slate-100'
                   }`}
                  onClick={() => setIsAdminMode('prize')}
                >
                  ğŸ’° {t.prizeCalculator}
                 </button>
                                <button
                   className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                     isAdminMode === 'admin' 
                       ? 'bg-indigo-600 text-white' 
                       : !isHost
                       ? 'bg-slate-500 text-slate-400 cursor-not-allowed'
                       : 'bg-slate-700 hover:bg-slate-600 text-slate-100'
                   }`}
                   onClick={() => {
                     if (isAdminMode === 'admin') {
                       setIsAdminMode(false)
                     } else if (isAdminMode === false || isAdminMode === 'prize') {
                       if (isHost) {
                       setRequestedAdminMode('admin')
                       setShowAdminLogin(true)
                       }
                     }
                   }}
                   disabled={!isHost}
                 >
                   âš™ï¸ {t.tournamentSettings} {!isHost && 'ğŸ‘‘'}
                 </button>
             </div>

                           {/* Main Tournament Content - Only show when not in prize calculator or admin mode */}
              {isAdminMode === false && (
             <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                             {/* LEFT PANEL - Player Management */}
               <div className="bg-slate-800/60 backdrop-blur border border-slate-700 rounded-2xl p-6 shadow-lg">
                 <h2 className="text-2xl font-semibold text-slate-100 mb-4">{t.tableTitle}</h2>
                 
                 {/* Player Count & Random Seating */}
                 <div className="flex items-center justify-between mb-4">
                   <div className="flex items-center gap-3">
                     <label className="text-slate-300">{t.playersCount}</label>
                     <select
                       className={`border rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 ${
                         gameStarted || !isHost
                           ? 'bg-slate-700/40 border-slate-600 text-slate-400 cursor-not-allowed' 
                           : 'bg-slate-900/60 border-slate-700 text-slate-100'
                       }`}
                       value={numPlayers}
                       onChange={(e) => updateNumPlayers(Number(e.target.value))}
                       disabled={gameStarted || !isHost}
                     >
                       {[2,3,4,5,6,7,8,9].map(n => (
                         <option key={n} value={n}>{n}</option>
                       ))}
                     </select>
                     {gameStarted && (
                       <span className="text-xs text-slate-400">ğŸ”’ Locked</span>
                     )}
                     {!gameStarted && !isHost && (
                       <span className="text-xs text-amber-400">ğŸ‘‘ Host Only</span>
                     )}
                   </div>
                   <button 
                     className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                       gameStarted || !isHost
                         ? 'bg-slate-500 text-slate-400 cursor-not-allowed' 
                         : 'bg-slate-700 hover:bg-slate-600 text-slate-100'
                     }`}
                     onClick={seatRandom}
                     disabled={gameStarted || !isHost}
                   >
                     {gameStarted ? `ğŸ”’ ${t.seatingLocked}` : !isHost ? `ğŸ‘‘ ${t.hostOnly}` : t.randomSeating}
                   </button>
                 </div>

                                                                                          {/* Circular Table Visualization - Players evenly distributed */}
                  <div className="relative w-full h-80 mb-6 bg-slate-900/40 rounded-2xl border border-slate-600 overflow-hidden">
                     {/* Table surface - Perfect circle */}
                     <div className="absolute inset-12 bg-gradient-to-br from-emerald-800/40 to-emerald-600/20 rounded-full border-2 border-emerald-500/30"></div>
                    
                    {/* Center Aces */}
                    <div className="absolute inset-0 flex items-center justify-center">
                      <div className="flex gap-4 text-4xl font-bold text-slate-300">
                        <span>â™ </span>
                        <span className="text-red-400">â™¥</span>
                        <span className="text-red-400">â™¦</span>
                        <span>â™£</span>
                      </div>
                    </div>
                    
                                          {/* Player seats - Perfect circular positioning */}
                      {players.map((player, idx) => {
                       // Calculate position on a perfect circle
                       const centerX = 50 // 50% from left
                       const centerY = 50 // 50% from top
                       const radius = 38 // 38% radius for player positioning (optimized for frame fit)
                       
                       // Calculate angle for each player (evenly distributed)
                       const angleStep = (2 * Math.PI) / numPlayers
                       const angle = idx * angleStep - Math.PI / 2 // Start from top (-90 degrees)
                       
                       // Calculate position
                       const x = centerX + radius * Math.cos(angle)
                       const y = centerY + radius * Math.sin(angle)
                        
                        return (
                          <div
                            key={player.id}
                            className={`absolute w-20 h-20 rounded-full border-2 flex items-center justify-center text-sm font-medium transition-all ${
                              eliminatedIds.includes(player.id)
                                ? 'bg-rose-700/60 border-rose-600 text-rose-100'
                                : 'bg-slate-700/60 border-slate-500 text-slate-100 hover:bg-slate-600/60'
                            }`}
                            style={{
                             left: `${x}%`,
                             top: `${y}%`,
                              transform: 'translate(-50%, -50%)'
                            }}
                          >
                            <div className="text-center">
                              <div className="text-xs font-bold">{player.name}</div>
                              <div className="text-xs opacity-75">
                                {rebuyCounts[player.id] || 0} {t.rebuys}
                              </div>
                              {maxRebuys > 0 && (rebuyCounts[player.id] || 0) >= maxRebuys && (
                                <div className="text-xs text-amber-400 font-bold mt-1">
                                  {t.maxReached}
                                </div>
                              )}
                            </div>
                          </div>
                        )
                      })}
                  </div>

                 {/* Player Grid */}
                 {!gameStarted && (
                   <div className="mb-3 p-2 bg-amber-900/30 border border-amber-600/50 rounded-lg">
                     <div className="text-amber-200 text-xs text-center">
                       ğŸ”’ {t.playerControlsLocked}
                     </div>
                   </div>
                 )}
                 <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                   {players.map((player, idx) => (
                     <div key={player.id} className="bg-slate-900/40 rounded-lg border border-slate-600 p-3">
                       {/* Player Header */}
                       <div className="flex items-center justify-between mb-2">
                         <span className="text-slate-300 text-sm font-medium">{t.seat} {idx + 1}</span>
                         <button
                           className={`px-3 py-1 text-xs rounded-md border font-medium ${
                             gameStarted
                               ? (eliminatedIds.includes(player.id) 
                               ? 'bg-rose-700/60 border-rose-600 text-rose-100' 
                                   : 'bg-emerald-700/40 border-emerald-600 text-emerald-100')
                               : 'bg-slate-500 border-slate-400 text-slate-300 cursor-not-allowed'
                           }`}
                           onClick={() => toggleEliminated(player.id)}
                           disabled={!gameStarted}
                         >
                           {gameStarted 
                             ? (eliminatedIds.includes(player.id) ? t.out : t.in)
                             : `ğŸ”’ ${t.locked}`
                           }
                         </button>

                       </div>
                       
                       {/* Player Name */}
                       <input
                         className={`w-full border rounded-lg px-3 py-2 text-sm mb-2 ${
                           gameStarted || !isHost
                             ? 'bg-slate-700/40 border-slate-600 text-slate-400 cursor-not-allowed' 
                             : 'bg-slate-900/60 border-slate-700 text-slate-100 focus:outline-none focus:ring-2 focus:ring-indigo-500'
                         }`}
                         type="text"
                         value={player.name}
                         onChange={(e) => updatePlayerName(idx, e.target.value)}
                         placeholder={t.playerPlaceholder(idx + 1)}
                         disabled={gameStarted || !isHost}
                       />
                       {!gameStarted && !isHost && (
                         <div className="text-xs text-amber-400 mb-2">ğŸ‘‘ Host Only</div>
                       )}
                       
                       {/* Rebuy Controls */}
                       <div className="flex items-center justify-between">
                           <span className="text-slate-300 text-xs">{t.rebuys}:</span>
                         <div className="flex items-center gap-2">
                           <button
                             className={`px-2 py-1 text-xs rounded-md border ${
                               gameStarted
                                 ? 'bg-slate-700/60 border-slate-600 text-slate-100 hover:bg-slate-600/60'
                                 : 'bg-slate-500 border-slate-400 text-slate-300 cursor-not-allowed'
                             }`}
                             onClick={() => removeRebuy(player.id)}
                             disabled={!gameStarted}
                           >
                             {gameStarted ? '-' : 'ğŸ”’'}
                           </button>
                           <span className="text-slate-300 text-sm font-mono min-w-[2rem] text-center">
                             {rebuyCounts[player.id] || 0}
                           </span>
                           <button
                               className={`px-2 py-1 text-xs rounded-md border font-medium ${
                                 gameStarted
                                   ? ((rebuyCounts[player.id] || 0) >= maxRebuys
                                   ? 'bg-slate-500 text-slate-400 cursor-not-allowed'
                                       : 'bg-slate-700/60 border-slate-600 text-slate-100 hover:bg-slate-600/60')
                                   : 'bg-slate-500 border-slate-400 text-slate-300 cursor-not-allowed'
                               }`}
                             onClick={() => addRebuy(player.id)}
                               disabled={!gameStarted || (rebuyCounts[player.id] || 0) >= maxRebuys}
                           >
                             {gameStarted ? '+' : 'ğŸ”’'}
                           </button>
                         </div>
                           {maxRebuys > 0 && (
                             <span className="text-xs text-slate-500">
                               {t.maxReached}: {maxRebuys}
                             </span>
                           )}
                       </div>

                     </div>
                   ))}
                 </div>
               </div>

                             {/* RIGHT PANEL - Tournament Management */}
               <div className="bg-slate-800/60 backdrop-blur border border-slate-700 rounded-2xl p-6 shadow-lg">
                 <h2 className="text-2xl font-semibold text-slate-100 mb-4">{t.tournamentTitle}</h2>
                 
                 {/* Host vs Guest Permissions */}
                 <div className="mb-4 p-3 bg-slate-700/30 rounded-lg border border-slate-600">
                   <div className="text-sm text-slate-300 mb-2">
                     <span className="font-medium">ğŸ‘‘ Host Only:</span> Start Game, Pause/Resume, Reset Timer, Break Controls
                   </div>
                   <div className="text-sm text-slate-300">
                     <span className="font-medium">âœ… All Players:</span> Rebuys, Eliminations, Player Names (before game starts)
                   </div>
                 </div>
                 
                 {/* Connection Test */}
                 <div className="mb-4 p-3 bg-blue-900/20 rounded-lg border border-blue-600">
                   <div className="text-sm text-blue-300 mb-2">
                     <span className="font-medium">ğŸ”— Connection Status:</span> {isConnected ? 'Connected' : 'Disconnected'}
                   </div>
                   <div className="text-sm text-blue-300 mb-2">
                     <span className="font-medium">ğŸ‘‘ Host Status:</span> {isHost ? 'Host' : 'Guest'}
                   </div>
                   <div className="text-sm text-blue-300 mb-2">
                     <span className="font-medium">ğŸ†” Device ID:</span> {deviceId}
                   </div>
                   <div className="text-sm text-blue-300 mb-2">
                     <span className="font-medium">ğŸ  Room ID:</span> {getCurrentRoomId()}
                   </div>
                   <button 
                     className="px-3 py-1 text-xs bg-blue-600 hover:bg-blue-500 text-white rounded"
                     onClick={() => {
                       console.log('ğŸ§ª TEST: Current state:', {
                         eliminatedIds,
                         rebuyCounts,
                         deviceId,
                         roomId: getCurrentRoomId()
                       })
                       // Force a sync to test
                       syncGameState({
                         isRunning,
                         gameStarted,
                         players,
                         eliminatedIds,
                         rebuyCounts,
                         currentLevelIndex,
                         remainingSeconds,
                         breakSeconds,
                         isOnBreak,
                         addonBreakTriggered,
                         addonBreakPending,
                         spotifyUrl,
                         currentTrack
                       })
                     }}
                   >
                     ğŸ§ª Test Sync
                   </button>
                 </div>
                 
                 {/* Level Settings */}
                  <div className="space-y-4 mb-4">
                    {/* Time Format Selection */}
                    <div className="flex items-center gap-4">
                   <label className="text-slate-300">{t.levelTime}</label>
                      <div className="flex items-center gap-2">
                        <label className={`flex items-center gap-2 ${!isHost ? 'text-slate-400' : 'text-slate-300'}`}>
                          <input
                            type="radio"
                            name="timeFormat"
                            className={`w-4 h-4 ${!isHost ? 'opacity-50' : 'accent-indigo-600'}`}
                            checked={timeFormat === 'minutes'}
                            onChange={() => isHost ? setTimeFormat('minutes') : null}
                            disabled={!isHost}
                          />
                          {t.minutes}
                        </label>
                        <label className={`flex items-center gap-2 ${!isHost ? 'text-slate-400' : 'text-slate-300'}`}>
                          <input
                            type="radio"
                            name="timeFormat"
                            className={`w-4 h-4 ${!isHost ? 'opacity-50' : 'accent-indigo-600'}`}
                            checked={timeFormat === 'mmss'}
                            onChange={() => isHost ? setTimeFormat('mmss') : null}
                            disabled={!isHost}
                          />
                          {t.mmss}
                        </label>
                      </div>
                    </div>
                    
                    {/* Time Input Based on Format */}
                    {timeFormat === 'minutes' ? (
                      <div className="flex items-center gap-4">
                   <input
                       className={`w-20 border border-slate-700 rounded-lg px-3 py-2 text-center focus:outline-none focus:ring-2 focus:ring-indigo-500 ${
                         !isHost
                           ? 'bg-slate-700/40 border-slate-600 text-slate-400 cursor-not-allowed' 
                           : 'bg-slate-900/60 border-slate-700 text-slate-100'
                       }`}
                     type="number"
                     min="1"
                     value={minutesPerLevel}
                       onChange={(e) => isHost ? setMinutesPerLevel(Number(e.target.value)) : null}
                       disabled={!isHost}
                   />
                        <span className="text-slate-300">{t.minutes}</span>
                      </div>
                    ) : (
                      <div className="flex items-center gap-4">
                                                 <input
                           className="w-24 bg-slate-900/60 border border-slate-700 rounded-lg px-3 py-2 text-slate-100 text-center focus:outline-none focus:ring-2 focus:ring-indigo-500 font-mono"
                           type="text"
                           pattern="^([0-9]|[0-5][0-9]):([0-5][0-9])$"
                           placeholder="10:00"
                           value={timePerLevelMMSS}
                           onChange={(e) => {
                             const value = e.target.value
                             // Validate MM:SS format
                             if (/^([0-9]|[0-5][0-9]):([0-5][0-9])$/.test(value)) {
                               setTimePerLevelMMSS(value)
                             } else if (value === '' || value === ':' || /^[0-9:]*$/.test(value)) {
                               // Allow partial input while typing
                               setTimePerLevelMMSS(value)
                             }
                           }}
                           onBlur={(e) => {
                             // Format properly when leaving the field
                             const value = e.target.value
                             if (value && !/^([0-9]|[0-5][0-9]):([0-5][0-9])$/.test(value)) {
                               // Try to fix common input errors
                               const parts = value.split(':')
                               if (parts.length === 2) {
                                 const mins = Math.min(59, Math.max(0, parseInt(parts[0]) || 0))
                                 const secs = Math.min(59, Math.max(0, parseInt(parts[1]) || 0))
                                 setTimePerLevelMMSS(`${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`)
                               } else {
                                 // Default to 10:00 if invalid
                                 setTimePerLevelMMSS('10:00')
                               }
                             }
                           }}
                         />
                        <span className="text-slate-300">{t.mmss}</span>
                      </div>
                    )}
                    
                    {/* Apply Button */}
                    <div className="flex justify-center">
                      <button
                        className="px-6 py-2 bg-emerald-600 hover:bg-emerald-500 text-white font-medium rounded-lg transition-colors flex items-center gap-2"
                        onClick={() => {
                          // Apply the new time settings to the current timer
                          if (timeFormat === 'minutes') {
                            setRemainingSeconds(minutesPerLevel * 60)
                          } else {
                            // Parse MM:SS format
                            const [minutes, seconds] = timePerLevelMMSS.split(':').map(Number)
                            const totalSeconds = (minutes * 60) + (seconds || 0)
                            setRemainingSeconds(totalSeconds)
                          }
                        }}
                      >
                        âœ… {t.applySettings}
                      </button>
                    </div>
                    
                    {/* Sound Setting */}
                    <div className="flex items-center gap-2">
                   <label className="flex items-center gap-2 text-slate-300">
                     <input
                       type="checkbox"
                       className="w-4 h-4 accent-indigo-600"
                       checked={soundEnabled}
                       onChange={(e) => setSoundEnabled(e.target.checked)}
                     />
                     {t.sound}
                   </label>
                    </div>
                 </div>

                 {/* Current Level Display */}
                 <div className="bg-gradient-to-br from-indigo-600/20 to-fuchsia-600/10 border border-slate-700 rounded-xl p-6 mb-4">
                   <div className="text-center mb-4">
                     <div className="text-sm text-slate-300 mb-1">{t.currentLevel}</div>
                     <div className="text-4xl font-bold text-slate-100">{t.level} {currentLevel.level}</div>
                   </div>
                   
                   <div className="grid grid-cols-2 gap-4 mb-4">
                     <div className="bg-slate-900/60 rounded-lg p-4 border border-slate-700 text-center">
                       <div className="text-sm text-slate-400 mb-1">{t.smallBlind}</div>
                       <div className="text-2xl font-semibold text-slate-100">{currentLevel.smallBlind}</div>
                     </div>
                     <div className="bg-slate-900/60 rounded-lg p-4 border border-slate-700 text-center">
                       <div className="text-sm text-slate-400 mb-1">{t.bigBlind}</div>
                       <div className="text-2xl font-semibold text-slate-100">{currentLevel.bigBlind}</div>
                     </div>
                   </div>

                   {/* Next Level Preview */}
                   {currentLevelIndex < levels.length - 1 && (
                     <div className="border-t border-slate-600 pt-4">
                       <div className="text-sm text-slate-400 mb-2 text-center">{t.nextLevel}</div>
                       <div className="grid grid-cols-2 gap-4">
                         <div className="bg-slate-800/40 rounded-lg p-3 border border-slate-600 text-center">
                           <div className="text-xs text-slate-500">{t.smallBlind}</div>
                           <div className="text-lg font-medium text-slate-300">{levels[currentLevelIndex + 1].smallBlind}</div>
                         </div>
                         <div className="bg-slate-800/40 rounded-lg p-3 border border-slate-600 text-center">
                           <div className="text-xs text-slate-500">{t.bigBlind}</div>
                           <div className="text-lg font-medium text-slate-300">{levels[currentLevelIndex + 1].bigBlind}</div>
                         </div>
                       </div>
                     </div>
                   )}
                 </div>

                 {/* Start Game Button */}
                 {!gameStarted && (
                   <div className="text-center mb-6">
                     <div className="text-sm text-slate-300 mb-3">{t.readyToStart}</div>
                     <button 
                       className={`px-8 py-4 rounded-xl font-bold text-lg transition-all transform ${
                         !isHost
                           ? 'bg-slate-500 text-slate-300 cursor-not-allowed'
                           : isAddonTimeValid() 
                             ? 'hover:scale-105 bg-gradient-to-r from-emerald-600 to-green-600 hover:from-emerald-500 hover:to-green-500 text-white shadow-lg' 
                             : 'bg-slate-500 text-slate-300 cursor-not-allowed'
                       }`}
                       onClick={isHost ? startGame : null}
                       disabled={!isHost || !isAddonTimeValid()}
                     >
                       ğŸš€ {t.startGame}
                     </button>
                     <div className="text-xs text-slate-400 mt-2">
                       {!isHost ? 'ğŸ‘‘ Host Only' : t.startGameLocked}
                     </div>
                     {!isAddonTimeValid() && (
                       <div className="text-xs text-red-400 mt-2">
                         {t.cannotStartWithPastAddon}
                       </div>
                     )}
                   </div>
                 )}
                 
                 {/* Game Started Indicator */}
                 {gameStarted && (
                   <div className="text-center mb-6">
                     <div className="inline-flex items-center gap-2 px-4 py-2 bg-emerald-600/20 border border-emerald-500/30 rounded-full">
                       <span className="w-2 h-2 bg-emerald-400 rounded-full animate-pulse"></span>
                       <span className="text-emerald-300 font-medium">{t.tournamentStarted}</span>
                     </div>
                   </div>
                 )}
                 
                 {/* Timer */}
                 <div className="text-center mb-4">
                   <div className="text-sm text-slate-300 mb-2">{t.timer}</div>
                   <div className="text-6xl font-mono text-slate-100 mb-4">
                     {currentLevelIndex === levels.length - 1 && remainingSeconds === 0 
                       ? t.infinite 
                       : formatTime(remainingSeconds)
                     }
                   </div>
                   
                   {/* Final Level Indicator */}
                   {currentLevelIndex === levels.length - 1 && remainingSeconds === 0 && (
                     <div className="text-lg text-amber-400 font-medium mb-3 animate-pulse">
                       ğŸ {t.finalLevel}
                     </div>
                   )}
                   
                                                             {/* Addon Break Pending Indicator */}
                   {addonBreakPending && (
                     <div className="text-lg text-blue-400 font-medium mb-3 animate-pulse">
                       â³ {t.addonBreakPending}
                     </div>
                   )}
                       

                     
                                          {/* Addon Timer Display */}
                      {addonTime && (
                        <div className="mb-4">
                          <div className="text-sm text-amber-300 mb-1">{t.addonIn} :</div>
                          <div className={`text-2xl font-mono font-bold ${
                            formatTimeUntilAddon() === '00:00' 
                              ? 'text-red-400 animate-pulse' 
                              : 'text-amber-100'
                          }`}>
                            {formatTimeUntilAddon()}
                          </div>
                          {formatTimeUntilAddon() === '00:00' && (
                            <div className="text-xs text-red-400 font-bold mt-1 animate-pulse">
                              {t.addonTime}
                            </div>
                          )}
                          {addonBreakTriggered && gameStarted && (
                            <div className="text-xs text-blue-400 font-bold mt-1">
                              {addonBreakPending 
                                ? t.addonBreakPending
                                : t.addonBreakActive
                              }
                            </div>
                          )}
                        </div>
                      )}
                      
                      {/* Addon Time Not Set Message */}
                      {!addonTime && gameStarted && (
                        <div className="text-center text-slate-400 text-sm mb-4">
                          {t.noAddonTimeSet}
                        </div>
                      )}
                     
                   <div className="flex gap-3 justify-center">
                     <button 
                          className={`px-6 py-3 rounded-lg font-medium transition-colors ${
                            !isHost
                              ? 'bg-slate-500 text-slate-300 cursor-not-allowed'
                              : !gameStarted
                                ? 'bg-slate-500 text-slate-300 cursor-not-allowed' 
                                : isOnBreak 
                                  ? 'bg-slate-500 text-slate-300 cursor-not-allowed' 
                                  : 'bg-indigo-600 hover:bg-indigo-500 text-white'
                          }`}
                       onClick={isHost ? handleStartPause : null}
                          disabled={!isHost || !gameStarted || isOnBreak}
                     >
                       {!isHost ? 'ğŸ‘‘ Host Only' : (!gameStarted ? t.startGameFirst : (isRunning ? t.pause : t.resume))}
                     </button>
                     <button 
                       className={`px-6 py-3 rounded-lg font-medium transition-colors ${
                         !isHost
                           ? 'bg-slate-500 text-slate-300 cursor-not-allowed'
                           : !gameStarted 
                             ? 'bg-slate-500 text-slate-300 cursor-not-allowed' 
                             : 'bg-slate-700 hover:bg-slate-600 text-slate-100'
                       }`}
                       onClick={isHost ? handleReset : null}
                       disabled={!isHost || !gameStarted}
                     >
                       {!isHost ? 'ğŸ‘‘ Host Only' : t.reset}
                     </button>
                   </div>
                 </div>

                 {/* Break Timer & Tournament Info */}
                 <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                   {/* Break Timer */}
                   <div className="bg-slate-900/40 rounded-lg p-4 border border-slate-600">
                     <div className="text-center mb-3">
                       <div className="text-sm text-slate-300 mb-1">{t.breakTimer}</div>
                       <div className="text-3xl font-mono text-slate-100 mb-3">{formatTime(breakSeconds)}</div>
                       <div className="flex gap-2 justify-center mb-3">
                         <button
                           className={`px-3 py-2 text-xs rounded-md border w-12 text-center ${
                             !isHost || !gameStarted
                               ? 'bg-slate-500/60 border-slate-500 text-slate-400 cursor-not-allowed' 
                               : 'bg-slate-700/60 border-slate-600 text-slate-100 hover:bg-slate-600/60'
                           }`}
                           onClick={isHost ? (() => startBreak(5)) : null}
                           disabled={!isHost || !gameStarted}
                         >
                           5m
                         </button>
                         <button
                           className={`px-3 py-2 text-xs rounded-md border w-12 text-center ${
                             !isHost || !gameStarted
                               ? 'bg-slate-500/60 border-slate-500 text-slate-400 cursor-not-allowed' 
                               : 'bg-slate-700/60 border-slate-600 text-slate-100 hover:bg-slate-600/60'
                           }`}
                           onClick={isHost ? (() => startBreak(10)) : null}
                           disabled={!isHost || !gameStarted}
                         >
                           10m
                         </button>
                         <button
                           className={`px-3 py-2 text-xs rounded-md border w-12 text-center ${
                             !isHost || !gameStarted
                               ? 'bg-slate-500/60 border-slate-500 text-slate-400 cursor-not-allowed' 
                               : 'bg-slate-700/60 border-slate-600 text-slate-100 hover:bg-slate-600/60'
                           }`}
                           onClick={isHost ? (() => startBreak(15)) : null}
                           disabled={!isHost || !gameStarted}
                         >
                           15m
                         </button>
                       </div>
                       <div className="w-full flex justify-center">
                         <button
                           className={`px-4 py-2 text-xs rounded-md border font-medium w-20 text-center ${
                             !isHost || !gameStarted
                               ? 'bg-slate-500/60 border-slate-500 text-slate-400 cursor-not-allowed'
                               : isOnBreak && breakSeconds > 0
                                 ? 'bg-amber-600/60 border-amber-600 text-amber-100'
                                 : 'bg-slate-700/60 border-slate-600 text-slate-100'
                           }`}
                           onClick={isHost ? toggleBreakPause : null}
                           disabled={!isHost || !gameStarted || breakSeconds === 0}
                         >
                           {!isHost ? 'ğŸ‘‘ Host' : (!gameStarted ? t.startGameFirst : (isOnBreak ? t.pause : t.resume))}
                         </button>
                       </div>
                       

                     </div>
                   </div>

                   {/* Tournament Info */}
                   <div className="bg-slate-900/40 rounded-lg p-4 border border-slate-600">
                     <div className="text-center">
                       {/* Game Status Indicator */}
                       <div className="mb-3">
                         <div className={`inline-flex items-center gap-2 px-3 py-1 rounded-full text-xs font-medium ${
                           gameStarted 
                             ? 'bg-emerald-600/20 border border-emerald-500/30 text-emerald-300' 
                             : 'bg-slate-600/20 border border-slate-500/30 text-slate-300'
                         }`}>
                           <span className={`w-2 h-2 rounded-full ${gameStarted ? 'bg-emerald-400 animate-pulse' : 'bg-slate-400'}`}></span>
                           {gameStarted ? t.tournamentActive : t.tournamentSetup}
                         </div>
                       </div>
                       
                       <div className="text-sm text-slate-300 mb-2">{t.totalTime}</div>
                       <div className="text-2xl font-mono text-slate-100 mb-3">{formatElapsedTime(elapsedSeconds)}</div>
                       
                                                {/* Tournament Settings Display */}
                         <div className="border-t border-slate-600 pt-3 mt-3">
                           <div className="grid grid-cols-2 gap-3 text-xs">
                             <div className="text-slate-400">
                               <div>{t.maxRebuysLabel}</div>
                               <div className="text-slate-200 font-medium">{maxRebuys}</div>
                             </div>
                             <div className="text-slate-400">
                               <div>{t.addonTimeLabel}</div>
                               <div className="text-slate-200 font-medium">{addonTime || t.off}</div>
                             </div>
                           </div>
                           
                           {/* Addon Break Status */}
                           {addonTime && (
                             <div className="col-span-2 border-t border-slate-600 pt-2 mt-2">
                               <div className="text-slate-400">
                                 <div>{t.addonBreakStatus}</div>
                                 <div className={`font-medium ${
                                   addonBreakTriggered 
                                     ? 'text-blue-400' 
                                     : 'text-slate-200'
                                 }`}>
                                   {addonBreakTriggered 
                                     ? (addonBreakPending 
                                         ? t.waitingForLevelEnd
                                         : t.active
                                       ) 
                                     : t.waiting
                                   }
                                 </div>
                               </div>
                             </div>
                           )}
                         
                         {/* Pricing Summary */}
                         <div className="border-t border-slate-600 pt-3 mt-3">
                           <div className="text-xs text-slate-400 mb-2">{t.tournamentPricing}</div>
                           <div className="grid grid-cols-2 gap-3 text-xs">
                                                            <div className="text-slate-400">
                                 <div>{t.buyInLabel}</div>
                                 <div className="text-slate-200 font-medium">{getCurrencySymbol()}{buyInPrice}</div>
                               </div>
                               <div className="text-slate-400">
                                 <div>{t.rebuyLabel}</div>
                                 <div className="text-slate-200 font-medium">{getCurrencySymbol()}{rebuyPrice}</div>
                               </div>
                             </div>
                             <div className="border-t border-slate-600 pt-2 mt-2">
                               <div className="text-xs text-slate-400">
                                 <div>{t.currentRebuys}</div>
                                 <div className="text-slate-200 font-medium">{Object.values(rebuyCounts).reduce((sum, count) => sum + count, 0)}</div>
                               </div>
                               <div className="text-xs text-slate-400 mt-1">
                                 <div>{t.totalPrizePool}</div>
                                 <div className="text-emerald-300 font-bold text-sm">{getCurrencySymbol()}{totalPrizePool}</div>
                               </div>
                             </div>
                         </div>
                       </div>
                     </div>
                   </div>
                 </div>
               </div>
             </div>
           )}

           {/* Enhanced Spotify Widget - Only show on main tournament tab */}
           {isAdminMode === false && (
             <div className="spotify-widget bg-gradient-to-br from-slate-800/80 to-slate-900/60 backdrop-blur border border-slate-700 rounded-2xl p-6 shadow-lg mt-6 min-h-fit">
               <div className="flex items-center gap-3 mb-6">
                 <div className="w-12 h-12 bg-gradient-to-br from-green-500 to-emerald-600 rounded-xl flex items-center justify-center shadow-lg">
                   <span className="text-2xl">ğŸµ</span>
                 </div>
                 <div>
                   <h2 className="text-2xl font-bold text-slate-100">{t.spotifyMusic}</h2>
                   <p className="text-slate-400 text-sm">{t.setMood}</p>
                 </div>
               </div>
               
               <div className="space-y-6">
                 {/* Input Section */}
                 <div className="bg-slate-900/40 rounded-xl p-4 border border-slate-600/50">
                   <label className="block text-slate-300 text-sm font-medium mb-3">
                     ğŸ¯ {t.pasteSpotifyLink}
                   </label>
                   <div className="flex gap-3">
                     <input
                       className="flex-1 bg-slate-800/60 border border-slate-600 rounded-lg px-4 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-green-500 transition-all"
                       type="text"
                       value={spotifyUrl}
                       onChange={(e) => setSpotifyUrl(e.target.value)}
                       placeholder="https://open.spotify.com/track/... or https://open.spotify.com/playlist/..."
                       onKeyPress={(e) => e.key === 'Enter' && handleSpotifyPlay()}
                     />
                     <button 
                       className={`px-6 py-3 rounded-lg font-semibold transition-all transform hover:scale-105 active:scale-95 ${
                         spotifyUrl.trim() 
                           ? 'bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-400 hover:to-emerald-500 text-white shadow-lg' 
                           : 'bg-slate-600 text-slate-400 cursor-not-allowed'
                       }`}
                       onClick={handleSpotifyPlay}
                       disabled={!spotifyUrl.trim()}
                     >
                       {spotifyUrl.trim() ? t.play : t.enterUrl}
                     </button>
                   </div>
                   {spotifyUrl.trim() && (
                     <div className="mt-3 text-xs text-slate-400">
                       {t.pressEnter}
                     </div>
                   )}
                 </div>
                 
                 {/* Player Section */}
                 {currentTrack ? (
                   <div className="bg-gradient-to-br from-slate-900/60 to-slate-800/40 rounded-xl p-6 border border-slate-600/50 shadow-inner">
                     <div className="flex items-center justify-between mb-4">
                       <div className="flex items-center gap-3">
                         <div className="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center animate-pulse">
                           <div className="w-2 h-2 bg-white rounded-full"></div>
                         </div>
                         <span className="text-slate-200 font-semibold">{t.nowPlaying}</span>
                       </div>
                       <button
                         className="px-4 py-2 text-sm rounded-lg bg-red-600/80 hover:bg-red-500 text-white font-medium transition-all transform hover:scale-105 active:scale-95 shadow-lg"
                         onClick={() => setCurrentTrack(null)}
                       >
                         {t.stop}
                       </button>
                     </div>
                     
                     <div className="bg-black/20 rounded-lg p-2 border border-slate-600/30 overflow-hidden h-96">
                       <iframe
                         src={`${extractSpotifyEmbedUrl(currentTrack.url)}?theme=0`}
                         width="100%"
                         height="100%"
                         frameBorder="0"
                         allowFullScreen=""
                         allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"
                         loading="lazy"
                         className="rounded-lg w-full h-full"
                         style={{
                           backgroundColor: 'transparent',
                           border: 'none',
                           outline: 'none'
                         }}
                       ></iframe>
                     </div>
                     
                     <div className="mt-4 text-center">
                       <div className="inline-flex items-center gap-2 px-4 py-2 bg-green-500/20 border border-green-500/30 rounded-full">
                         <span className="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>
                         <span className="text-green-300 text-sm font-medium">{t.musicPlaying}</span>
                       </div>
                     </div>
                   </div>
                 ) : (
                   <div className="bg-gradient-to-br from-slate-900/40 to-slate-800/20 rounded-xl p-8 border border-slate-600/30 text-center">
                     <div className="w-20 h-20 bg-gradient-to-br from-slate-700 to-slate-600 rounded-full flex items-center justify-center mx-auto mb-4 shadow-lg">
                       <span className="text-4xl">ğŸµ</span>
                     </div>
                     <div className="text-slate-200 text-xl font-semibold mb-2">{t.noMusicPlaying}</div>
                     <div className="text-slate-400 text-sm mb-4">{t.pasteLinkAndPlay}</div>
                     <div className="flex items-center justify-center gap-4 text-xs text-slate-500">
                       <div className="flex items-center gap-1">
                         <span>ğŸ§</span>
                         <span>{t.supportsTracks}</span>
                       </div>
                       <div className="flex items-center gap-1">
                         <span>ğŸ®</span>
                         <span>{t.perfectForTournaments}</span>
                       </div>
                     </div>
                   </div>
                 )}
                 
                 {/* Quick Actions */}
                 <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
                   <button 
                     className="p-3 bg-slate-700/40 hover:bg-slate-600/40 border border-slate-600/50 rounded-lg text-slate-300 text-sm font-medium transition-all hover:scale-105 active:scale-95"
                     onClick={() => setSpotifyUrl('https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M')}
                   >
                     ğŸ¯ {t.todaysTopHits}
                   </button>
                   <button 
                     className="p-3 bg-slate-700/40 hover:bg-slate-600/40 border border-slate-600/50 rounded-lg text-slate-300 text-sm font-medium transition-all hover:scale-105 active:scale-95"
                     onClick={() => setSpotifyUrl('https://open.spotify.com/playlist/37i9dQZF1DX5Vy6DFOcx00')}
                   >
                     ğŸ¸ {t.rockClassics}
                   </button>
                   <button 
                     className="p-3 bg-slate-700/40 hover:bg-slate-600/40 border border-slate-600/50 rounded-lg text-slate-300 text-sm font-medium transition-all hover:scale-105 active:scale-95"
                     onClick={() => setSpotifyUrl('https://open.spotify.com/playlist/37i9dQZF1DX4WYpdgoIcn6')}
                   >
                     ğŸµ {t.chillVibes}
                   </button>
                 </div>
               </div>
             </div>
           )}

                                         {/* Prize Calculator Tab */}
              {isAdminMode === 'prize' && (
                <div className="bg-slate-800/60 backdrop-blur border border-slate-700 rounded-2xl p-6 shadow-lg">
                  <h2 className="text-2xl font-semibold text-slate-100 mb-6">ğŸ’° {t.prizeCalculator}</h2>
                  
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {/* Input Section */}
                    <div className="space-y-4">
                      <div>
                        <label className="text-slate-300 text-sm block mb-2">Total Prize Pool (Auto-calculated)</label>
                        <div className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-4 py-3 text-slate-100 text-lg font-mono">
                          {getCurrencySymbol()}{totalPrizePool}
                        </div>
                        <div className="text-xs text-slate-500 mt-1">
                                           {t.buyInsLabel} {getCurrencySymbol()}{buyInPrice} Ã— {numPlayers} = {getCurrencySymbol()}{buyInPrice * numPlayers} |
                 {t.rebuysLabel} {Object.values(rebuyCounts).reduce((sum, count) => sum + count, 0)} Ã— {getCurrencySymbol()}{rebuyPrice} = {getCurrencySymbol()}{Object.values(rebuyCounts).reduce((sum, count) => sum + (count * rebuyPrice), 0)}
                        </div>
                      </div>
                      
                      <div>
                        <label className="text-slate-300 text-sm block mb-2">{t.ratioLabel}</label>
                        <input
                          className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-4 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg"
                          type="text"
                          value={ratioInput}
                          onChange={(e) => setRatioInput(e.target.value)}
                          placeholder={Array.from({ length: numWinners }, (_, i) => 
                            i === 0 ? '50' : i === 1 ? '30' : i === 2 ? '20' : Math.max(5, 20 - (i * 5))
                          ).join('/')}
                        />
                        <div className="text-xs text-slate-500 mt-1">
                          {t.enterNumbersSeparated.replace('{numWinners}', numWinners).replace('{example}', Array.from({ length: numWinners }, (_, i) => 
                            i === 0 ? '50' : i === 1 ? '30' : i === 2 ? '20' : Math.max(5, 20 - (i * 5))
                          ).join('/'))}
                        </div>
                      </div>
                    </div>
                    
                    {/* Info Note */}
                    <div className="col-span-1 md:col-span-2 mb-4">
                      <div className="bg-blue-600/20 border border-blue-500/30 rounded-lg p-4">
                        <div className="flex items-center gap-2 mb-2">
                          <span className="text-blue-400">â„¹ï¸</span>
                          <span className="text-blue-200 font-medium">{t.automaticPrizeCalculation}</span>
                        </div>
                        <div className="text-blue-100 text-sm">
                          {t.prizePoolAutoCalc}
                        </div>
                      </div>
                    </div>
                    
                    {/* Results Section */}
                     <div className="space-y-4">
                       {prizeDistribution.map((prize, index) => {
                         const placeColors = [
                           { bg: 'from-amber-600/20 to-yellow-600/10', border: 'border-amber-500/30', text: 'text-amber-300', value: 'text-amber-100' },
                           { bg: 'from-slate-600/20 to-gray-600/10', border: 'border-slate-500/30', text: 'text-slate-300', value: 'text-slate-100' },
                           { bg: 'from-orange-600/20 to-red-600/10', border: 'border-orange-500/30', text: 'text-orange-300', value: 'text-orange-100' },
                           { bg: 'from-purple-600/20 to-indigo-600/10', border: 'border-purple-500/30', text: 'text-purple-300', value: 'text-purple-100' },
                           { bg: 'from-teal-600/20 to-cyan-600/10', border: 'border-teal-500/30', text: 'text-teal-300', value: 'text-teal-100' },
                           { bg: 'from-pink-600/20 to-rose-600/10', border: 'border-pink-500/30', text: 'text-pink-300', value: 'text-pink-100' },
                           { bg: 'from-emerald-600/20 to-green-600/10', border: 'border-emerald-500/30', text: 'text-emerald-300', value: 'text-emerald-100' },
                           { bg: 'from-blue-600/20 to-sky-600/10', border: 'border-blue-500/30', text: 'text-blue-300', value: 'text-blue-100' },
                           { bg: 'from-violet-600/20 to-purple-600/10', border: 'border-violet-500/30', text: 'text-violet-300', value: 'text-violet-100' },
                           { bg: 'from-lime-600/20 to-green-600/10', border: 'border-lime-500/30', text: 'text-lime-300', value: 'text-lime-100' }
                         ]
                         
                         const colors = placeColors[index] || placeColors[0]
                         const placeNames = [
                           t.firstPlace, t.secondPlace, t.thirdPlace,
                           t.place4th, t.place5th, t.place6th, t.place7th, t.place8th, t.place9th, t.place10th
                         ]
                         
                         return (
                           <div key={index} className={`bg-gradient-to-br ${colors.bg} border ${colors.border} rounded-xl p-6`}>
                             <div className="text-center mb-4">
                               <div className={`text-sm ${colors.text} mb-1`}>{placeNames[index]}</div>
                               <div className={`text-2xl font-bold ${colors.value}`}>{getCurrencySymbol()}{prize}</div>
                             </div>
                           </div>
                         )
                       })}
                     </div>
                  </div>
                </div>
              )}

              {/* Admin Mode - Settings Only */}
              {isAdminMode === 'admin' && (
                <div className="space-y-6">
                  {/* Tournament Settings Section */}
                  <div className="bg-slate-800/60 backdrop-blur border border-slate-700 rounded-2xl p-6 shadow-lg">
                    <h2 className="text-2xl font-semibold text-slate-100 mb-6">âš™ï¸ {t.tournamentSettings}</h2>
                    
                    {/* Start Game Notice */}
                    {!gameStarted && (
                      <div className="bg-amber-600/20 border border-amber-500/30 rounded-lg p-4 mb-6">
                        <div className="flex items-center gap-2 mb-2">
                          <span className="text-amber-400">âš ï¸</span>
                          <span className="text-amber-200 font-medium">{t.tournamentSetupMode}</span>
                        </div>
                        <div className="text-amber-100 text-sm">
                          {t.canStillModify}
                        </div>
                      </div>
                    )}
                    
                    {gameStarted && (
                      <div className="bg-emerald-600/20 border border-emerald-500/30 rounded-lg p-4 mb-6">
                        <div className="flex items-center gap-2 mb-2">
                          <span className="text-emerald-400">ğŸ”’</span>
                          <span className="text-emerald-200 font-medium">{t.tournamentActiveSettingsLocked}</span>
                        </div>
                        <div className="text-emerald-100 text-sm">
                          {t.tournamentStartedSettingsLocked}
                        </div>
                      </div>
                    )}
                    
                    <div className="grid grid-cols-1 lg:grid-cols-6 gap-4">
                      {/* Number of Winners Setting */}
                      <div className="space-y-3">
                        <div>
                          <label className="text-slate-300 text-sm block mb-2">{t.numWinners}</label>
                          <input
                            className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-3 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg"
                            type="number"
                            min="1"
                            max="10"
                            value={numWinners}
                            onChange={(e) => setNumWinners(Number(e.target.value))}
                            placeholder="3"
                          />
                          <div className="text-xs text-slate-500 mt-1">
                             {t.winnersHelper}
                          </div>
                        </div>
                      </div>
                      
                      {/* Addon Time Setting */}
                      <div className="space-y-3">
                        <div>
                          <label className="text-slate-300 text-sm block mb-2">{t.addonTime}</label>
                          <input
                            className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-3 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg"
                            type="text"
                            value={addonTime}
                            onChange={(e) => {
                              const newTime = e.target.value
                              setAddonTime(newTime)
                              // Reset addon break state when time changes or is cleared
                              if (newTime === '' || newTime !== addonTime) {
                                setAddonBreakTriggered(false)
                                setAddonBreakPending(false)
                                console.log('ğŸ”„ Addon time changed, resetting break state')
                              }
                            }}
                            placeholder="20:30"
                            pattern="^([0-1]?[0-9]|2[0-5][0-9]):[0-5][0-9]$"
                          />
                          <div className="text-xs text-slate-500 mt-1">
                             {t.addonTimeHelper}
                          </div>
                          
                          {/* Addon Time Validation */}
                          {addonTime && (
                            (() => {
                              const now = new Date()
                              const currentHour = now.getHours()
                              const currentMinute = now.getMinutes()
                              const [targetHour, targetMinute] = addonTime.split(':').map(Number)
                              
                              if (targetHour !== undefined && targetMinute !== undefined) {
                                const currentTotalMinutes = currentHour * 60 + currentMinute
                                const targetTotalMinutes = targetHour * 60 + targetMinute
                                
                                if (targetTotalMinutes <= currentTotalMinutes) {
                                  return (
                                    <div className="text-xs text-red-400 mt-1">
                                      âš ï¸ {t.addonTimeInPast}
                                    </div>
                                  )
                                } else {
                                  return (
                                    <div className="text-xs text-green-400 mt-1">
                                      âœ… {t.addonTimeValid}
                                    </div>
                                  )
                                }
                              }
                              return null
                            })()
                          )}
                        </div>
                      </div>
                      
                      {/* Max Rebuys Setting */}
                      <div className="space-y-3">
                        <div>
                          <label className="text-slate-300 text-sm block mb-2">{t.maxRebuys}</label>
                          <input
                            className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-3 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg"
                            type="number"
                            min="0"
                            max="10"
                            value={maxRebuys}
                            onChange={(e) => {
                              const newValue = Number(e.target.value)
                              setMaxRebuys(newValue)
                              // Sync to Firebase
                              setTimeout(() => {
                                syncGameState({
                                  isRunning,
                                  gameStarted,
                                  players,
                                  eliminatedIds,
                                  rebuyCounts,
                                  currentLevelIndex,
                                  remainingSeconds,
                                  breakSeconds,
                                  isOnBreak,
                                  addonBreakTriggered,
                                  addonBreakPending,
                                  spotifyUrl,
                                  currentTrack
                                })
                              }, 100)
                            }}
                            placeholder="3"
                          />
                          <div className="text-xs text-slate-500 mt-1">
                             {t.rebuysHelper}
                           </div>
                         </div>
                       </div>
                       
                       {/* Buy-in Price Setting */}
                       <div className="space-y-3">
                         <div>
                           <label className="text-slate-300 text-sm block mb-2">{t.buyInPrice}</label>
                           <div className="relative">
                           <input
                               className="w-full bg-slate-900/60 border border-slate-700 rounded-lg pl-8 pr-3 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg"
                             type="number"
                             min="0"
                             value={buyInPrice}
                             onChange={(e) => {
                               const newValue = Number(e.target.value)
                               setBuyInPrice(newValue)
                               // Sync to Firebase
                               setTimeout(() => {
                                 syncGameState({
                                   isRunning,
                                   gameStarted,
                                   players,
                                   eliminatedIds,
                                   rebuyCounts,
                                   currentLevelIndex,
                                   remainingSeconds,
                                   breakSeconds,
                                   isOnBreak,
                                   addonBreakTriggered,
                                   addonBreakPending,
                                   spotifyUrl,
                                   currentTrack
                                 })
                               }, 100)
                             }}
                             placeholder="50"
                           />
                             <span className="absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-300 text-lg pointer-events-none">{getCurrencySymbol()}</span>
                           </div>
                           <div className="text-xs text-slate-500 mt-1">
                             {t.buyInHelper}
                         </div>
                       </div>
                     </div>
                     
                       {/* Rebuy Price Setting */}
                       <div className="space-y-3">
                         <div>
                           <label className="text-slate-300 text-sm block mb-2">{t.rebuyPrice}</label>
                           <div className="relative">
                       <input
                               className="w-full bg-slate-900/60 border border-slate-700 rounded-lg pl-8 pr-3 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg"
                         type="number"
                         min="0"
                         value={rebuyPrice}
                         onChange={(e) => {
                           const newValue = Number(e.target.value)
                           setRebuyPrice(newValue)
                           // Sync to Firebase
                           setTimeout(() => {
                             syncGameState({
                               isRunning,
                               gameStarted,
                               players,
                               eliminatedIds,
                               rebuyCounts,
                               currentLevelIndex,
                               remainingSeconds,
                               breakSeconds,
                               isOnBreak,
                               addonBreakTriggered,
                               addonBreakPending,
                               spotifyUrl,
                               currentTrack
                             })
                           }, 100)
                         }}
                         placeholder="50"
                       />
                             <span className="absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-300 text-lg pointer-events-none">{getCurrencySymbol()}</span>
                           </div>
                       <div className="text-xs text-slate-500 mt-1">
                             {t.rebuyHelper}
                           </div>
                         </div>
                       </div>
                       
                       {/* Currency Setting */}
                       <div className="space-y-3">
                         <div>
                           <label className="text-slate-300 text-sm block mb-2">{t.currency}</label>
                           <select
                             className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-3 py-3 text-slate-100 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg"
                             value={currency}
                             onChange={(e) => {
                               const newValue = e.target.value
                               setCurrency(newValue)
                               // Sync to Firebase
                               setTimeout(() => {
                                 syncGameState({
                                   isRunning,
                                   gameStarted,
                                   players,
                                   eliminatedIds,
                                   rebuyCounts,
                                   currentLevelIndex,
                                   remainingSeconds,
                                   breakSeconds,
                                   isOnBreak,
                                   addonBreakTriggered,
                                   addonBreakPending,
                                   spotifyUrl,
                                   currentTrack
                                 })
                               }, 100)
                             }}
                           >
                             <option value="USD">USD ($)</option>
                             <option value="EUR">EUR (â‚¬)</option>
                             <option value="NIS">NIS (â‚ª)</option>
                           </select>
                           <div className="text-xs text-slate-500 mt-1">
                             {t.currencyHelper}
                           </div>
                         </div>
                       </div>
                     </div>
                     
                     {/* Game Management Buttons */}
                     <div className="mt-6 pt-6 border-t border-slate-600">
                       <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                         {/* Clear Saved Game Button */}
                         <div className="space-y-2">
                           <button
                             className="w-full px-4 py-3 rounded-md bg-red-600 hover:bg-red-500 text-white text-sm font-medium transition-colors"
                             onClick={() => {
                               if (confirm(t.confirmClearSavedGame)) {
                                 localStorage.removeItem('pokerTournamentState')
                                 window.location.reload()
                               }
                             }}
                           >
                             ğŸ—‘ï¸ {t.clearSavedGame}
                           </button>
                           <div className="text-xs text-slate-400 text-center">
                             {t.clearGameHelper}
                           </div>
                         </div>
                         
                         {/* Reset Players Button */}
                         <div className="space-y-2">
                           <button
                             className="w-full px-4 py-3 rounded-md bg-orange-600 hover:bg-orange-500 text-white text-sm font-medium transition-colors"
                             onClick={() => {
                               if (confirm(t.confirmResetPlayers)) {
                                 resetPlayers()
                               }
                             }}
                           >
                             ğŸ‘¥ {t.resetPlayers}
                           </button>
                           <div className="text-xs text-slate-400 text-center">
                             {t.resetPlayersHelper}
                           </div>
                         </div>
                         
                         {/* Reset Addon Break Button */}
                         <div className="space-y-2">
                           <button
                             className={`w-full px-4 py-3 rounded-md text-white text-sm font-medium transition-colors ${
                               gameStarted 
                                 ? 'bg-blue-600 hover:bg-blue-500' 
                                 : 'bg-slate-500 cursor-not-allowed'
                             }`}
                             onClick={() => {
                               if (!gameStarted) return
                               if (confirm(t.confirmResetAddonBreak)) {
                                 resetAddonBreak()
                               }
                             }}
                             disabled={!gameStarted}
                           >
                             ğŸ”„ {t.addonBreakReset}
                           </button>
                           <div className="text-xs text-slate-400 text-center">
                             {gameStarted ? t.addonBreakReset : t.lockedUntilGameStarts}
                           </div>
                         </div>
                         
                         {/* Test Addon Break Button */}
                         <div className="space-y-2">
                           <button
                             className={`w-full px-4 py-3 rounded-md text-white text-sm font-medium transition-colors ${
                               gameStarted 
                                 ? 'bg-green-600 hover:bg-green-500' 
                                 : 'bg-slate-500 cursor-not-allowed'
                             }`}
                             onClick={() => {
                               if (!gameStarted) return
                               if (confirm(t.confirmTestAddonBreak)) {
                                 startBreak(15)
                                 setAddonBreakTriggered(true)
                                 setAddonBreakPending(true)
                               }
                             }}
                             disabled={!gameStarted}
                           >
                             ğŸ§ª {t.testAddonBreak}
                           </button>
                           <div className="text-xs text-slate-400 text-center">
                             {gameStarted ? t.testAddonBreak : t.lockedUntilGameStarts}
                           </div>
                         </div>
                       </div>
                     </div>
                  </div>

                  {/* Blind Levels Management Section */}
                  <div className="bg-slate-800/60 backdrop-blur border border-slate-700 rounded-2xl p-6 shadow-lg">
                    {/* User Defaults Status */}
                    {userDefaultLevels && (
                      <div className="mb-4 p-3 bg-blue-900/30 border border-blue-600 rounded-lg">
                        <div className="text-sm text-blue-300">
                          ğŸ’¾ {t.personalDefaultsAvailable}
                          <span className="text-blue-400 ml-2">
                            ({userDefaultLevels.levels.length} {t.levels}, 
                            {t.chip} {userDefaultLevels.lowestChipValue})
                          </span>
                        </div>
                      </div>
                    )}
                    
                    <div className="flex items-center justify-between mb-6">
                      <h2 className="text-2xl font-semibold text-slate-100">âš™ï¸ {t.levelsTitle}</h2>
                      <div className="flex items-center gap-2">
                        <button
                          className="px-3 py-1.5 rounded-md bg-emerald-600 hover:bg-emerald-500 text-white text-sm"
                          onClick={addBlindLevel}
                        >
                          â• {t.addLevel}
                        </button>
                        <button
                          className={`px-3 py-1.5 rounded-md text-white text-sm transition-colors ${
                            levels.length > 1 
                              ? 'bg-red-600 hover:bg-red-500' 
                              : 'bg-slate-500 cursor-not-allowed'
                          }`}
                          onClick={removeBlindLevel}
                          disabled={levels.length <= 1}
                          title={t.removeLevelHelper}
                        >
                          â– {t.removeLevel}
                        </button>
                        <button
                          className="px-3 py-1.5 rounded-md bg-amber-600 hover:bg-amber-500 text-white text-sm"
                          onClick={resetToDefaults}
                        >
                          ğŸ”„ {t.resetDefaults}
                        </button>
                     
                       <button
                          className="px-3 py-1.5 rounded-md bg-green-600 hover:bg-green-500 text-white text-sm"
                          onClick={saveUserDefaultLevels}
                        >
                          ğŸ’¾ {t.saveUserDefaults}
                       </button>
                        
                        <button
                          className="px-3 py-1.5 rounded-md bg-blue-600 hover:bg-blue-500 text-white text-sm"
                          onClick={restoreUserDefaultLevels}
                          disabled={!userDefaultLevels}
                        >
                          ğŸ”„ {t.restoreUserDefaults}
                        </button>
                        
                        <button
                          className="px-3 py-1.5 rounded-md bg-red-600 hover:bg-red-500 text-white text-sm"
                          onClick={clearUserDefaultLevels}
                          disabled={!userDefaultLevels}
                        >
                          ğŸ—‘ï¸ {t.clearUserDefaults}
                        </button>
                       </div>
                     </div>
                     
                    {/* Lowest Chip Value, Number of Levels, and Generate Blinds */}
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                      <div className="space-y-3">
                        <label className="text-slate-300 text-sm block">{t.lowestChipValue}</label>
                                                 <input
                           className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-3 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg"
                           type="number"
                           min="1"
                           value={lowestChipValue}
                           onChange={(e) => setLowestChipValue(Number(e.target.value))}
                           placeholder="25"
                         />
                        <div className="text-xs text-slate-500">
                          {t.lowestChipHelper}
                        </div>
                      </div>
                      
                      <div className="space-y-3">
                        <label className="text-slate-300 text-sm block">{t.numberOfLevels}</label>
                                                 <input
                           className="w-full bg-slate-900/60 border border-slate-700 rounded-lg px-3 py-3 text-slate-100 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg"
                           type="number"
                           min="1"
                           max="100"
                           value={desiredNumberOfLevels}
                           onChange={(e) => setDesiredNumberOfLevels(Number(e.target.value))}
                           placeholder="12"
                         />
                        <div className="text-xs text-slate-500">
                          {t.numberOfLevelsHelper}
                        </div>
                      </div>
                      
                      <div className="space-y-3">
                        <label className="text-slate-300 text-sm block">{t.generateBlinds}</label>
                       <button
                          className="w-full px-4 py-3 rounded-lg bg-blue-600 hover:bg-blue-500 text-white font-medium transition-colors"
                          onClick={generateBlindLevels}
                        >
                          ğŸ² {t.calculateLevels}
                       </button>
                        <div className="text-xs text-slate-500">
                          {t.generateBlindsHelper}
                        </div>
                         </div>
                       </div>
                     

                       
                       <div className="overflow-x-auto">
                         <table className="min-w-full text-sm">
                           <thead>
                             <tr className="text-slate-300">
                               <th className="text-right py-2 pr-4">{t.level}</th>
                               <th className="text-right py-2 pr-4">{t.smallBlind}</th>
                               <th className="text-right py-2 pr-4">{t.bigBlind}</th>
                             </tr>
                           </thead>
                           <tbody>
                             {levels.map((level, index) => (
                               <tr key={level.level} className="border-t border-slate-700">
                                 <td className="py-2 pr-4 text-right font-medium">{level.level}</td>
                                 <td className="py-2 pr-4">
                                   <input
                                     className="w-20 text-center bg-slate-900/60 border border-slate-700 rounded-lg px-2 py-1 text-slate-100 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                     type="number"
                                     value={level.smallBlind}
                                     onChange={(e) => {
                                       const newLevels = [...levels]
                                       newLevels[index].smallBlind = Number(e.target.value)
                                       setLevels(newLevels)
                                     }}
                                   />
                                 </td>
                                 <td className="py-2 pr-4">
                                   <input
                                     className="w-20 text-center bg-slate-900/60 border border-slate-700 rounded-lg px-2 py-1 text-slate-100 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                     type="number"
                                     value={level.bigBlind}
                                     onChange={(e) => {
                                       const newLevels = [...levels]
                                       newLevels[index].bigBlind = Number(e.target.value)
                                       setLevels(newLevels)
                                     }}
                                   />
                                 </td>
                               </tr>
                             ))}
                           </tbody>
                         </table>
                       </div>
                     </div>
                   </div>
                 )}
               </>
             )}
           </div>
         )
       }

      const root = ReactDOM.createRoot(document.getElementById('root'))
      root.render(<App />)
    </script>
  </body>
</html>
